/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.58.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIKeyCreateDto
 */
export interface APIKeyCreateDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyCreateDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface APIKeyCreateResponseDto
 */
export interface APIKeyCreateResponseDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyCreateResponseDto
     */
    'secret': string;
    /**
     * 
     * @type {APIKeyResponseDto}
     * @memberof APIKeyCreateResponseDto
     */
    'apiKey': APIKeyResponseDto;
}
/**
 * 
 * @export
 * @interface APIKeyResponseDto
 */
export interface APIKeyResponseDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface APIKeyUpdateDto
 */
export interface APIKeyUpdateDto {
    /**
     * 
     * @type {string}
     * @memberof APIKeyUpdateDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AddAssetsDto
 */
export interface AddAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAssetsDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddAssetsResponseDto
 */
export interface AddAssetsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AddAssetsResponseDto
     */
    'successfullyAdded': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAssetsResponseDto
     */
    'alreadyInAlbum': Array<string>;
    /**
     * 
     * @type {AlbumResponseDto}
     * @memberof AddAssetsResponseDto
     */
    'album'?: AlbumResponseDto;
}
/**
 * 
 * @export
 * @interface AddUsersDto
 */
export interface AddUsersDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddUsersDto
     */
    'sharedUserIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminSignupResponseDto
 */
export interface AdminSignupResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSignupResponseDto
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface AlbumCountResponseDto
 */
export interface AlbumCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'owned': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'shared': number;
    /**
     * 
     * @type {number}
     * @memberof AlbumCountResponseDto
     */
    'sharing': number;
}
/**
 * 
 * @export
 * @interface AlbumResponseDto
 */
export interface AlbumResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AlbumResponseDto
     */
    'assetCount': number;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumName': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponseDto
     */
    'albumThumbnailAssetId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumResponseDto
     */
    'shared': boolean;
    /**
     * 
     * @type {Array<UserResponseDto>}
     * @memberof AlbumResponseDto
     */
    'sharedUsers': Array<UserResponseDto>;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof AlbumResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     * 
     * @type {UserResponseDto}
     * @memberof AlbumResponseDto
     */
    'owner': UserResponseDto;
}
/**
 * 
 * @export
 * @interface AllJobStatusResponseDto
 */
export interface AllJobStatusResponseDto {
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'thumbnail-generation-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'metadata-extraction-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'video-conversion-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'object-tagging-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'clip-encoding-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'storage-template-migration-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'background-task-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'search-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'recognize-faces-queue': JobStatusDto;
    /**
     * 
     * @type {JobStatusDto}
     * @memberof AllJobStatusResponseDto
     */
    'sidecar-queue': JobStatusDto;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckDto
 */
export interface AssetBulkUploadCheckDto {
    /**
     * 
     * @type {Array<AssetBulkUploadCheckItem>}
     * @memberof AssetBulkUploadCheckDto
     */
    'assets': Array<AssetBulkUploadCheckItem>;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckItem
 */
export interface AssetBulkUploadCheckItem {
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckItem
     */
    'id': string;
    /**
     * base64 or hex encoded sha1 hash
     * @type {string}
     * @memberof AssetBulkUploadCheckItem
     */
    'checksum': string;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckResponseDto
 */
export interface AssetBulkUploadCheckResponseDto {
    /**
     * 
     * @type {Array<AssetBulkUploadCheckResult>}
     * @memberof AssetBulkUploadCheckResponseDto
     */
    'results': Array<AssetBulkUploadCheckResult>;
}
/**
 * 
 * @export
 * @interface AssetBulkUploadCheckResult
 */
export interface AssetBulkUploadCheckResult {
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'action': AssetBulkUploadCheckResultActionEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'reason'?: AssetBulkUploadCheckResultReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetBulkUploadCheckResult
     */
    'assetId'?: string;
}

export const AssetBulkUploadCheckResultActionEnum = {
    Accept: 'accept',
    Reject: 'reject'
} as const;

export type AssetBulkUploadCheckResultActionEnum = typeof AssetBulkUploadCheckResultActionEnum[keyof typeof AssetBulkUploadCheckResultActionEnum];
export const AssetBulkUploadCheckResultReasonEnum = {
    Duplicate: 'duplicate',
    UnsupportedFormat: 'unsupported-format'
} as const;

export type AssetBulkUploadCheckResultReasonEnum = typeof AssetBulkUploadCheckResultReasonEnum[keyof typeof AssetBulkUploadCheckResultReasonEnum];

/**
 * 
 * @export
 * @interface AssetCountByTimeBucket
 */
export interface AssetCountByTimeBucket {
    /**
     * 
     * @type {string}
     * @memberof AssetCountByTimeBucket
     */
    'timeBucket': string;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByTimeBucket
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface AssetCountByTimeBucketResponseDto
 */
export interface AssetCountByTimeBucketResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AssetCountByTimeBucketResponseDto
     */
    'totalCount': number;
    /**
     * 
     * @type {Array<AssetCountByTimeBucket>}
     * @memberof AssetCountByTimeBucketResponseDto
     */
    'buckets': Array<AssetCountByTimeBucket>;
}
/**
 * 
 * @export
 * @interface AssetCountByUserIdResponseDto
 */
export interface AssetCountByUserIdResponseDto {
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'audio': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'other': number;
    /**
     * 
     * @type {number}
     * @memberof AssetCountByUserIdResponseDto
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface AssetFileUploadResponseDto
 */
export interface AssetFileUploadResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AssetFileUploadResponseDto
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof AssetFileUploadResponseDto
     */
    'duplicate': boolean;
}
/**
 * 
 * @export
 * @interface AssetResponseDto
 */
export interface AssetResponseDto {
    /**
     * 
     * @type {AssetTypeEnum}
     * @memberof AssetResponseDto
     */
    'type': AssetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalPath': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'originalFileName': string;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'resized': boolean;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileCreatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'fileModifiedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isFavorite': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AssetResponseDto
     */
    'isArchived': boolean;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'mimeType': string | null;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'duration': string;
    /**
     * 
     * @type {ExifResponseDto}
     * @memberof AssetResponseDto
     */
    'exifInfo'?: ExifResponseDto;
    /**
     * 
     * @type {SmartInfoResponseDto}
     * @memberof AssetResponseDto
     */
    'smartInfo'?: SmartInfoResponseDto;
    /**
     * 
     * @type {string}
     * @memberof AssetResponseDto
     */
    'livePhotoVideoId'?: string | null;
    /**
     * 
     * @type {Array<TagResponseDto>}
     * @memberof AssetResponseDto
     */
    'tags'?: Array<TagResponseDto>;
    /**
     * 
     * @type {Array<PersonResponseDto>}
     * @memberof AssetResponseDto
     */
    'people'?: Array<PersonResponseDto>;
    /**
     * base64 encoded sha1 hash
     * @type {string}
     * @memberof AssetResponseDto
     */
    'checksum': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AssetTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Other: 'OTHER'
} as const;

export type AssetTypeEnum = typeof AssetTypeEnum[keyof typeof AssetTypeEnum];


/**
 * 
 * @export
 * @interface AuthDeviceResponseDto
 */
export interface AuthDeviceResponseDto {
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthDeviceResponseDto
     */
    'current': boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'deviceType': string;
    /**
     * 
     * @type {string}
     * @memberof AuthDeviceResponseDto
     */
    'deviceOS': string;
}
/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetDto
 */
export interface CheckDuplicateAssetDto {
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckDuplicateAssetResponseDto
 */
export interface CheckDuplicateAssetResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'isExist': boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckDuplicateAssetResponseDto
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsDto
 */
export interface CheckExistingAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsDto
     */
    'deviceAssetIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CheckExistingAssetsDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CheckExistingAssetsResponseDto
 */
export interface CheckExistingAssetsResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckExistingAssetsResponseDto
     */
    'existingIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAlbumDto
 */
export interface CreateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumDto
     */
    'albumName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'sharedWithUserIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAlbumDto
     */
    'assetIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAlbumShareLinkDto
 */
export interface CreateAlbumShareLinkDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumShareLinkDto
     */
    'albumId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumShareLinkDto
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlbumShareLinkDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlbumShareLinkDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAlbumShareLinkDto
     */
    'showExif'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAlbumShareLinkDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateAssetsShareLinkDto
 */
export interface CreateAssetsShareLinkDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAssetsShareLinkDto
     */
    'assetIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateAssetsShareLinkDto
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAssetsShareLinkDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAssetsShareLinkDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAssetsShareLinkDto
     */
    'showExif'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAssetsShareLinkDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateProfileImageResponseDto
 */
export interface CreateProfileImageResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileImageResponseDto
     */
    'profileImagePath': string;
}
/**
 * 
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof CreateTagDto
     */
    'type': TagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateTagDto
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'storageLabel'?: string | null;
}
/**
 * 
 * @export
 * @interface CuratedLocationsResponseDto
 */
export interface CuratedLocationsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'resizePath': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedLocationsResponseDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface CuratedObjectsResponseDto
 */
export interface CuratedObjectsResponseDto {
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'resizePath': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceAssetId': string;
    /**
     * 
     * @type {string}
     * @memberof CuratedObjectsResponseDto
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface DeleteAssetDto
 */
export interface DeleteAssetDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteAssetDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteAssetResponseDto
 */
export interface DeleteAssetResponseDto {
    /**
     * 
     * @type {DeleteAssetStatus}
     * @memberof DeleteAssetResponseDto
     */
    'status': DeleteAssetStatus;
    /**
     * 
     * @type {string}
     * @memberof DeleteAssetResponseDto
     */
    'id': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DeleteAssetStatus = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type DeleteAssetStatus = typeof DeleteAssetStatus[keyof typeof DeleteAssetStatus];


/**
 * 
 * @export
 * @interface DownloadFilesDto
 */
export interface DownloadFilesDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DownloadFilesDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface EditSharedLinkDto
 */
export interface EditSharedLinkDto {
    /**
     * 
     * @type {string}
     * @memberof EditSharedLinkDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditSharedLinkDto
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EditSharedLinkDto
     */
    'allowUpload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditSharedLinkDto
     */
    'allowDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditSharedLinkDto
     */
    'showExif'?: boolean;
}
/**
 * 
 * @export
 * @interface ExifResponseDto
 */
export interface ExifResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fileSizeInByte'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'make'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'model'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageWidth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'exifImageHeight'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'orientation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'dateTimeOriginal'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'modifyDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'timeZone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'lensModel'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'fNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'focalLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'iso'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'exposureTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExifResponseDto
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExifResponseDto
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface GetAssetByTimeBucketDto
 */
export interface GetAssetByTimeBucketDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetAssetByTimeBucketDto
     */
    'timeBucket': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetAssetByTimeBucketDto
     */
    'userId'?: string;
    /**
     * Include assets without thumbnails
     * @type {boolean}
     * @memberof GetAssetByTimeBucketDto
     */
    'withoutThumbs'?: boolean;
}
/**
 * 
 * @export
 * @interface GetAssetCountByTimeBucketDto
 */
export interface GetAssetCountByTimeBucketDto {
    /**
     * 
     * @type {TimeGroupEnum}
     * @memberof GetAssetCountByTimeBucketDto
     */
    'timeGroup': TimeGroupEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAssetCountByTimeBucketDto
     */
    'userId'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const JobCommand = {
    Start: 'start',
    Pause: 'pause',
    Resume: 'resume',
    Empty: 'empty'
} as const;

export type JobCommand = typeof JobCommand[keyof typeof JobCommand];


/**
 * 
 * @export
 * @interface JobCommandDto
 */
export interface JobCommandDto {
    /**
     * 
     * @type {JobCommand}
     * @memberof JobCommandDto
     */
    'command': JobCommand;
    /**
     * 
     * @type {boolean}
     * @memberof JobCommandDto
     */
    'force': boolean;
}


/**
 * 
 * @export
 * @interface JobCountsDto
 */
export interface JobCountsDto {
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'active': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'completed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'failed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'delayed': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'waiting': number;
    /**
     * 
     * @type {number}
     * @memberof JobCountsDto
     */
    'paused': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobName = {
    ThumbnailGenerationQueue: 'thumbnail-generation-queue',
    MetadataExtractionQueue: 'metadata-extraction-queue',
    VideoConversionQueue: 'video-conversion-queue',
    ObjectTaggingQueue: 'object-tagging-queue',
    RecognizeFacesQueue: 'recognize-faces-queue',
    ClipEncodingQueue: 'clip-encoding-queue',
    BackgroundTaskQueue: 'background-task-queue',
    StorageTemplateMigrationQueue: 'storage-template-migration-queue',
    SearchQueue: 'search-queue',
    SidecarQueue: 'sidecar-queue'
} as const;

export type JobName = typeof JobName[keyof typeof JobName];


/**
 * 
 * @export
 * @interface JobStatusDto
 */
export interface JobStatusDto {
    /**
     * 
     * @type {JobCountsDto}
     * @memberof JobStatusDto
     */
    'jobCounts': JobCountsDto;
    /**
     * 
     * @type {QueueStatusDto}
     * @memberof JobStatusDto
     */
    'queueStatus': QueueStatusDto;
}
/**
 * 
 * @export
 * @interface LoginCredentialDto
 */
export interface LoginCredentialDto {
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'userEmail': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseDto
     */
    'shouldChangePassword': boolean;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof LogoutResponseDto
     */
    'successful': boolean;
    /**
     * 
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface MapMarkerResponseDto
 */
export interface MapMarkerResponseDto {
    /**
     * 
     * @type {string}
     * @memberof MapMarkerResponseDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof MapMarkerResponseDto
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof MapMarkerResponseDto
     */
    'lon': number;
}
/**
 * 
 * @export
 * @interface OAuthCallbackDto
 */
export interface OAuthCallbackDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthCallbackDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigDto
 */
export interface OAuthConfigDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigDto
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface OAuthConfigResponseDto
 */
export interface OAuthConfigResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'passwordLoginEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthConfigResponseDto
     */
    'buttonText'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthConfigResponseDto
     */
    'autoLaunch'?: boolean;
}
/**
 * 
 * @export
 * @interface PersonResponseDto
 */
export interface PersonResponseDto {
    /**
     * 
     * @type {string}
     * @memberof PersonResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseDto
     */
    'thumbnailPath': string;
}
/**
 * 
 * @export
 * @interface PersonUpdateDto
 */
export interface PersonUpdateDto {
    /**
     * 
     * @type {string}
     * @memberof PersonUpdateDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface QueueStatusDto
 */
export interface QueueStatusDto {
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusDto
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusDto
     */
    'isPaused': boolean;
}
/**
 * 
 * @export
 * @interface RemoveAssetsDto
 */
export interface RemoveAssetsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveAssetsDto
     */
    'assetIds': Array<string>;
}
/**
 * 
 * @export
 * @interface SearchAlbumResponseDto
 */
export interface SearchAlbumResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof SearchAlbumResponseDto
     */
    'count': number;
    /**
     * 
     * @type {Array<AlbumResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'items': Array<AlbumResponseDto>;
    /**
     * 
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAlbumResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
}
/**
 * 
 * @export
 * @interface SearchAssetDto
 */
export interface SearchAssetDto {
    /**
     * 
     * @type {string}
     * @memberof SearchAssetDto
     */
    'searchTerm': string;
}
/**
 * 
 * @export
 * @interface SearchAssetResponseDto
 */
export interface SearchAssetResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof SearchAssetResponseDto
     */
    'count': number;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'items': Array<AssetResponseDto>;
    /**
     * 
     * @type {Array<SearchFacetResponseDto>}
     * @memberof SearchAssetResponseDto
     */
    'facets': Array<SearchFacetResponseDto>;
}
/**
 * 
 * @export
 * @interface SearchConfigResponseDto
 */
export interface SearchConfigResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof SearchConfigResponseDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SearchExploreItem
 */
export interface SearchExploreItem {
    /**
     * 
     * @type {string}
     * @memberof SearchExploreItem
     */
    'value': string;
    /**
     * 
     * @type {AssetResponseDto}
     * @memberof SearchExploreItem
     */
    'data': AssetResponseDto;
}
/**
 * 
 * @export
 * @interface SearchExploreResponseDto
 */
export interface SearchExploreResponseDto {
    /**
     * 
     * @type {string}
     * @memberof SearchExploreResponseDto
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<SearchExploreItem>}
     * @memberof SearchExploreResponseDto
     */
    'items': Array<SearchExploreItem>;
}
/**
 * 
 * @export
 * @interface SearchFacetCountResponseDto
 */
export interface SearchFacetCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof SearchFacetCountResponseDto
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof SearchFacetCountResponseDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SearchFacetResponseDto
 */
export interface SearchFacetResponseDto {
    /**
     * 
     * @type {string}
     * @memberof SearchFacetResponseDto
     */
    'fieldName': string;
    /**
     * 
     * @type {Array<SearchFacetCountResponseDto>}
     * @memberof SearchFacetResponseDto
     */
    'counts': Array<SearchFacetCountResponseDto>;
}
/**
 * 
 * @export
 * @interface SearchResponseDto
 */
export interface SearchResponseDto {
    /**
     * 
     * @type {SearchAlbumResponseDto}
     * @memberof SearchResponseDto
     */
    'albums': SearchAlbumResponseDto;
    /**
     * 
     * @type {SearchAssetResponseDto}
     * @memberof SearchResponseDto
     */
    'assets': SearchAssetResponseDto;
}
/**
 * 
 * @export
 * @interface ServerInfoResponseDto
 */
export interface ServerInfoResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskSizeRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUseRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailableRaw': number;
    /**
     * 
     * @type {number}
     * @memberof ServerInfoResponseDto
     */
    'diskUsagePercentage': number;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskSize': string;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskUse': string;
    /**
     * 
     * @type {string}
     * @memberof ServerInfoResponseDto
     */
    'diskAvailable': string;
}
/**
 * 
 * @export
 * @interface ServerPingResponse
 */
export interface ServerPingResponse {
    /**
     * 
     * @type {string}
     * @memberof ServerPingResponse
     */
    'res': string;
}
/**
 * 
 * @export
 * @interface ServerStatsResponseDto
 */
export interface ServerStatsResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof ServerStatsResponseDto
     */
    'usage': number;
    /**
     * 
     * @type {Array<UsageByUserDto>}
     * @memberof ServerStatsResponseDto
     */
    'usageByUser': Array<UsageByUserDto>;
}
/**
 * 
 * @export
 * @interface ServerVersionReponseDto
 */
export interface ServerVersionReponseDto {
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'major': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'minor': number;
    /**
     * 
     * @type {number}
     * @memberof ServerVersionReponseDto
     */
    'patch': number;
}
/**
 * 
 * @export
 * @interface SharedLinkResponseDto
 */
export interface SharedLinkResponseDto {
    /**
     * 
     * @type {SharedLinkType}
     * @memberof SharedLinkResponseDto
     */
    'type': SharedLinkType;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SharedLinkResponseDto
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {Array<AssetResponseDto>}
     * @memberof SharedLinkResponseDto
     */
    'assets': Array<AssetResponseDto>;
    /**
     * 
     * @type {AlbumResponseDto}
     * @memberof SharedLinkResponseDto
     */
    'album'?: AlbumResponseDto;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowUpload': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'allowDownload': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SharedLinkResponseDto
     */
    'showExif': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SharedLinkType = {
    Album: 'ALBUM',
    Individual: 'INDIVIDUAL'
} as const;

export type SharedLinkType = typeof SharedLinkType[keyof typeof SharedLinkType];


/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface SmartInfoResponseDto
 */
export interface SmartInfoResponseDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SmartInfoResponseDto
     */
    'objects'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SystemConfigDto
 */
export interface SystemConfigDto {
    /**
     * 
     * @type {SystemConfigFFmpegDto}
     * @memberof SystemConfigDto
     */
    'ffmpeg': SystemConfigFFmpegDto;
    /**
     * 
     * @type {SystemConfigOAuthDto}
     * @memberof SystemConfigDto
     */
    'oauth': SystemConfigOAuthDto;
    /**
     * 
     * @type {SystemConfigPasswordLoginDto}
     * @memberof SystemConfigDto
     */
    'passwordLogin': SystemConfigPasswordLoginDto;
    /**
     * 
     * @type {SystemConfigStorageTemplateDto}
     * @memberof SystemConfigDto
     */
    'storageTemplate': SystemConfigStorageTemplateDto;
}
/**
 * 
 * @export
 * @interface SystemConfigFFmpegDto
 */
export interface SystemConfigFFmpegDto {
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'crf': number;
    /**
     * 
     * @type {number}
     * @memberof SystemConfigFFmpegDto
     */
    'threads': number;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'preset': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetVideoCodec': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetAudioCodec': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'targetResolution': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'maxBitrate': string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigFFmpegDto
     */
    'twoPass': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigFFmpegDto
     */
    'transcode': SystemConfigFFmpegDtoTranscodeEnum;
}

export const SystemConfigFFmpegDtoTranscodeEnum = {
    All: 'all',
    Optimal: 'optimal',
    Required: 'required',
    Disabled: 'disabled'
} as const;

export type SystemConfigFFmpegDtoTranscodeEnum = typeof SystemConfigFFmpegDtoTranscodeEnum[keyof typeof SystemConfigFFmpegDtoTranscodeEnum];

/**
 * 
 * @export
 * @interface SystemConfigOAuthDto
 */
export interface SystemConfigOAuthDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'issuerUrl': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'buttonText': string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoRegister': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'autoLaunch': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigOAuthDto
     */
    'mobileOverrideEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemConfigOAuthDto
     */
    'mobileRedirectUri': string;
}
/**
 * 
 * @export
 * @interface SystemConfigPasswordLoginDto
 */
export interface SystemConfigPasswordLoginDto {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfigPasswordLoginDto
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SystemConfigStorageTemplateDto
 */
export interface SystemConfigStorageTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof SystemConfigStorageTemplateDto
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface SystemConfigTemplateStorageOptionDto
 */
export interface SystemConfigTemplateStorageOptionDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'yearOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'monthOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'dayOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'hourOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'minuteOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'secondOptions': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemConfigTemplateStorageOptionDto
     */
    'presetOptions': Array<string>;
}
/**
 * 
 * @export
 * @interface TagResponseDto
 */
export interface TagResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'id': string;
    /**
     * 
     * @type {TagTypeEnum}
     * @memberof TagResponseDto
     */
    'type': TagTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof TagResponseDto
     */
    'renameTagId'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TagTypeEnum = {
    Object: 'OBJECT',
    Face: 'FACE',
    Custom: 'CUSTOM'
} as const;

export type TagTypeEnum = typeof TagTypeEnum[keyof typeof TagTypeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ThumbnailFormat = {
    Jpeg: 'JPEG',
    Webp: 'WEBP'
} as const;

export type ThumbnailFormat = typeof ThumbnailFormat[keyof typeof ThumbnailFormat];


/**
 * 
 * @export
 * @enum {string}
 */

export const TimeGroupEnum = {
    Day: 'day',
    Month: 'month'
} as const;

export type TimeGroupEnum = typeof TimeGroupEnum[keyof typeof TimeGroupEnum];


/**
 * 
 * @export
 * @interface UpdateAlbumDto
 */
export interface UpdateAlbumDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAlbumDto
     */
    'albumThumbnailAssetId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAssetDto
 */
export interface UpdateAssetDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAssetDto
     */
    'tagIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isFavorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAssetDto
     */
    'isArchived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateAssetDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTagDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTagDto
     */
    'renameTagId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'storageLabel'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'shouldChangePassword'?: boolean;
}
/**
 * 
 * @export
 * @interface UsageByUserDto
 */
export interface UsageByUserDto {
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userFirstName': string;
    /**
     * 
     * @type {string}
     * @memberof UsageByUserDto
     */
    'userLastName': string;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'photos': number;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'videos': number;
    /**
     * 
     * @type {number}
     * @memberof UsageByUserDto
     */
    'usage': number;
}
/**
 * 
 * @export
 * @interface UserCountResponseDto
 */
export interface UserCountResponseDto {
    /**
     * 
     * @type {number}
     * @memberof UserCountResponseDto
     */
    'userCount': number;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'storageLabel': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'profileImagePath': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'shouldChangePassword': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponseDto
     */
    'oauthId': string;
}
/**
 * 
 * @export
 * @interface ValidateAccessTokenResponseDto
 */
export interface ValidateAccessTokenResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateAccessTokenResponseDto
     */
    'authStatus': boolean;
}

/**
 * APIKeyApi - axios parameter creator
 * @export
 */
export const APIKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (aPIKeyCreateDto: APIKeyCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyCreateDto' is not null or undefined
            assertParamExists('createKey', 'aPIKeyCreateDto', aPIKeyCreateDto)
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKey', 'id', id)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKey', 'id', id)
            // verify required parameter 'aPIKeyUpdateDto' is not null or undefined
            assertParamExists('updateKey', 'aPIKeyUpdateDto', aPIKeyUpdateDto)
            const localVarPath = `/api-key/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeyApi - functional programming interface
 * @export
 */
export const APIKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyCreateResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(aPIKeyCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIKeyResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(id, aPIKeyUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIKeyApi - factory interface
 * @export
 */
export const APIKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeyApiFp(configuration)
    return {
        /**
         * 
         * @param {APIKeyCreateDto} aPIKeyCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(aPIKeyCreateDto: APIKeyCreateDto, options?: any): AxiosPromise<APIKeyCreateResponseDto> {
            return localVarFp.createKey(aPIKeyCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(id: string, options?: any): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.getKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(options?: any): AxiosPromise<Array<APIKeyResponseDto>> {
            return localVarFp.getKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {APIKeyUpdateDto} aPIKeyUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(id: string, aPIKeyUpdateDto: APIKeyUpdateDto, options?: any): AxiosPromise<APIKeyResponseDto> {
            return localVarFp.updateKey(id, aPIKeyUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiCreateKeyRequest
 */
export interface APIKeyApiCreateKeyRequest {
    /**
     * 
     * @type {APIKeyCreateDto}
     * @memberof APIKeyApiCreateKey
     */
    readonly aPIKeyCreateDto: APIKeyCreateDto
}

/**
 * Request parameters for deleteKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiDeleteKeyRequest
 */
export interface APIKeyApiDeleteKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof APIKeyApiDeleteKey
     */
    readonly id: string
}

/**
 * Request parameters for getKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiGetKeyRequest
 */
export interface APIKeyApiGetKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof APIKeyApiGetKey
     */
    readonly id: string
}

/**
 * Request parameters for updateKey operation in APIKeyApi.
 * @export
 * @interface APIKeyApiUpdateKeyRequest
 */
export interface APIKeyApiUpdateKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof APIKeyApiUpdateKey
     */
    readonly id: string

    /**
     * 
     * @type {APIKeyUpdateDto}
     * @memberof APIKeyApiUpdateKey
     */
    readonly aPIKeyUpdateDto: APIKeyUpdateDto
}

/**
 * APIKeyApi - object-oriented interface
 * @export
 * @class APIKeyApi
 * @extends {BaseAPI}
 */
export class APIKeyApi extends BaseAPI {
    /**
     * 
     * @param {APIKeyApiCreateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public createKey(requestParameters: APIKeyApiCreateKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).createKey(requestParameters.aPIKeyCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {APIKeyApiDeleteKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public deleteKey(requestParameters: APIKeyApiDeleteKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).deleteKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {APIKeyApiGetKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getKey(requestParameters: APIKeyApiGetKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getKeys(options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).getKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {APIKeyApiUpdateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public updateKey(requestParameters: APIKeyApiUpdateKeyRequest, options?: AxiosRequestConfig) {
        return APIKeyApiFp(this.configuration).updateKey(requestParameters.id, requestParameters.aPIKeyUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlbumApi - axios parameter creator
 * @export
 */
export const AlbumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum: async (id: string, addAssetsDto: AddAssetsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'id', id)
            // verify required parameter 'addAssetsDto' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'addAssetsDto', addAssetsDto)
            const localVarPath = `/album/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum: async (id: string, addUsersDto: AddUsersDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUsersToAlbum', 'id', id)
            // verify required parameter 'addUsersDto' is not null or undefined
            assertParamExists('addUsersToAlbum', 'addUsersDto', addUsersDto)
            const localVarPath = `/album/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUsersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum: async (createAlbumDto: CreateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlbumDto' is not null or undefined
            assertParamExists('createAlbum', 'createAlbumDto', createAlbumDto)
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAlbumShareLinkDto} createAlbumShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbumSharedLink: async (createAlbumShareLinkDto: CreateAlbumShareLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAlbumShareLinkDto' is not null or undefined
            assertParamExists('createAlbumSharedLink', 'createAlbumShareLinkDto', createAlbumShareLinkDto)
            const localVarPath = `/album/create-shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumShareLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlbum', 'id', id)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive: async (id: string, name?: string, skip?: number, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadArchive', 'id', id)
            const localVarPath = `/album/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCountByUserId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album/count-by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo: async (id: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAlbumInfo', 'id', id)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums: async (shared?: boolean, assetId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum: async (id: string, removeAssetsDto: RemoveAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'id', id)
            // verify required parameter 'removeAssetsDto' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'removeAssetsDto', removeAssetsDto)
            const localVarPath = `/album/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum: async (id: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'userId', userId)
            const localVarPath = `/album/{id}/user/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo: async (id: string, updateAlbumDto: UpdateAlbumDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlbumInfo', 'id', id)
            // verify required parameter 'updateAlbumDto' is not null or undefined
            assertParamExists('updateAlbumInfo', 'updateAlbumDto', updateAlbumDto)
            const localVarPath = `/album/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlbumDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumApi - functional programming interface
 * @export
 */
export const AlbumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlbumApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToAlbum(id: string, addAssetsDto: AddAssetsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToAlbum(id, addAssetsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToAlbum(id: string, addUsersDto: AddUsersDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToAlbum(id, addUsersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbum(createAlbumDto: CreateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbum(createAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAlbumShareLinkDto} createAlbumShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbumSharedLink(createAlbumShareLinkDto: CreateAlbumShareLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbumSharedLink(createAlbumShareLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlbum(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArchive(id: string, name?: string, skip?: number, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArchive(id, name, skip, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumCountByUserId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumCountByUserId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumInfo(id: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumInfo(id, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlbums(shared?: boolean, assetId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlbumResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlbums(shared, assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromAlbum(id: string, removeAssetsDto: RemoveAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromAlbum(id, removeAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromAlbum(id: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromAlbum(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlbumInfo(id: string, updateAlbumDto: UpdateAlbumDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlbumInfo(id, updateAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlbumApi - factory interface
 * @export
 */
export const AlbumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlbumApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum(id: string, addAssetsDto: AddAssetsDto, key?: string, options?: any): AxiosPromise<AddAssetsResponseDto> {
            return localVarFp.addAssetsToAlbum(id, addAssetsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AddUsersDto} addUsersDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum(id: string, addUsersDto: AddUsersDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.addUsersToAlbum(id, addUsersDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAlbumDto} createAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(createAlbumDto: CreateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.createAlbum(createAlbumDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAlbumShareLinkDto} createAlbumShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbumSharedLink(createAlbumShareLinkDto: CreateAlbumShareLinkDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.createAlbumSharedLink(createAlbumShareLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlbum(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArchive(id: string, name?: string, skip?: number, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadArchive(id, name, skip, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumCountByUserId(options?: any): AxiosPromise<AlbumCountResponseDto> {
            return localVarFp.getAlbumCountByUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo(id: string, key?: string, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.getAlbumInfo(id, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [shared] 
         * @param {string} [assetId] Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums(shared?: boolean, assetId?: string, options?: any): AxiosPromise<Array<AlbumResponseDto>> {
            return localVarFp.getAllAlbums(shared, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum(id: string, removeAssetsDto: RemoveAssetsDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.removeAssetFromAlbum(id, removeAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum(id: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserFromAlbum(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAlbumDto} updateAlbumDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo(id: string, updateAlbumDto: UpdateAlbumDto, options?: any): AxiosPromise<AlbumResponseDto> {
            return localVarFp.updateAlbumInfo(id, updateAlbumDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addAssetsToAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiAddAssetsToAlbumRequest
 */
export interface AlbumApiAddAssetsToAlbumRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiAddAssetsToAlbum
     */
    readonly id: string

    /**
     * 
     * @type {AddAssetsDto}
     * @memberof AlbumApiAddAssetsToAlbum
     */
    readonly addAssetsDto: AddAssetsDto

    /**
     * 
     * @type {string}
     * @memberof AlbumApiAddAssetsToAlbum
     */
    readonly key?: string
}

/**
 * Request parameters for addUsersToAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiAddUsersToAlbumRequest
 */
export interface AlbumApiAddUsersToAlbumRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiAddUsersToAlbum
     */
    readonly id: string

    /**
     * 
     * @type {AddUsersDto}
     * @memberof AlbumApiAddUsersToAlbum
     */
    readonly addUsersDto: AddUsersDto
}

/**
 * Request parameters for createAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiCreateAlbumRequest
 */
export interface AlbumApiCreateAlbumRequest {
    /**
     * 
     * @type {CreateAlbumDto}
     * @memberof AlbumApiCreateAlbum
     */
    readonly createAlbumDto: CreateAlbumDto
}

/**
 * Request parameters for createAlbumSharedLink operation in AlbumApi.
 * @export
 * @interface AlbumApiCreateAlbumSharedLinkRequest
 */
export interface AlbumApiCreateAlbumSharedLinkRequest {
    /**
     * 
     * @type {CreateAlbumShareLinkDto}
     * @memberof AlbumApiCreateAlbumSharedLink
     */
    readonly createAlbumShareLinkDto: CreateAlbumShareLinkDto
}

/**
 * Request parameters for deleteAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiDeleteAlbumRequest
 */
export interface AlbumApiDeleteAlbumRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiDeleteAlbum
     */
    readonly id: string
}

/**
 * Request parameters for downloadArchive operation in AlbumApi.
 * @export
 * @interface AlbumApiDownloadArchiveRequest
 */
export interface AlbumApiDownloadArchiveRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiDownloadArchive
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof AlbumApiDownloadArchive
     */
    readonly name?: string

    /**
     * 
     * @type {number}
     * @memberof AlbumApiDownloadArchive
     */
    readonly skip?: number

    /**
     * 
     * @type {string}
     * @memberof AlbumApiDownloadArchive
     */
    readonly key?: string
}

/**
 * Request parameters for getAlbumInfo operation in AlbumApi.
 * @export
 * @interface AlbumApiGetAlbumInfoRequest
 */
export interface AlbumApiGetAlbumInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiGetAlbumInfo
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof AlbumApiGetAlbumInfo
     */
    readonly key?: string
}

/**
 * Request parameters for getAllAlbums operation in AlbumApi.
 * @export
 * @interface AlbumApiGetAllAlbumsRequest
 */
export interface AlbumApiGetAllAlbumsRequest {
    /**
     * 
     * @type {boolean}
     * @memberof AlbumApiGetAllAlbums
     */
    readonly shared?: boolean

    /**
     * Only returns albums that contain the asset Ignores the shared parameter undefined: get all albums
     * @type {string}
     * @memberof AlbumApiGetAllAlbums
     */
    readonly assetId?: string
}

/**
 * Request parameters for removeAssetFromAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiRemoveAssetFromAlbumRequest
 */
export interface AlbumApiRemoveAssetFromAlbumRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiRemoveAssetFromAlbum
     */
    readonly id: string

    /**
     * 
     * @type {RemoveAssetsDto}
     * @memberof AlbumApiRemoveAssetFromAlbum
     */
    readonly removeAssetsDto: RemoveAssetsDto
}

/**
 * Request parameters for removeUserFromAlbum operation in AlbumApi.
 * @export
 * @interface AlbumApiRemoveUserFromAlbumRequest
 */
export interface AlbumApiRemoveUserFromAlbumRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiRemoveUserFromAlbum
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof AlbumApiRemoveUserFromAlbum
     */
    readonly userId: string
}

/**
 * Request parameters for updateAlbumInfo operation in AlbumApi.
 * @export
 * @interface AlbumApiUpdateAlbumInfoRequest
 */
export interface AlbumApiUpdateAlbumInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumApiUpdateAlbumInfo
     */
    readonly id: string

    /**
     * 
     * @type {UpdateAlbumDto}
     * @memberof AlbumApiUpdateAlbumInfo
     */
    readonly updateAlbumDto: UpdateAlbumDto
}

/**
 * AlbumApi - object-oriented interface
 * @export
 * @class AlbumApi
 * @extends {BaseAPI}
 */
export class AlbumApi extends BaseAPI {
    /**
     * 
     * @param {AlbumApiAddAssetsToAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addAssetsToAlbum(requestParameters: AlbumApiAddAssetsToAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addAssetsToAlbum(requestParameters.id, requestParameters.addAssetsDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiAddUsersToAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public addUsersToAlbum(requestParameters: AlbumApiAddUsersToAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).addUsersToAlbum(requestParameters.id, requestParameters.addUsersDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiCreateAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public createAlbum(requestParameters: AlbumApiCreateAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).createAlbum(requestParameters.createAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiCreateAlbumSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public createAlbumSharedLink(requestParameters: AlbumApiCreateAlbumSharedLinkRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).createAlbumSharedLink(requestParameters.createAlbumShareLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiDeleteAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public deleteAlbum(requestParameters: AlbumApiDeleteAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).deleteAlbum(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiDownloadArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public downloadArchive(requestParameters: AlbumApiDownloadArchiveRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).downloadArchive(requestParameters.id, requestParameters.name, requestParameters.skip, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumCountByUserId(options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumCountByUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiGetAlbumInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAlbumInfo(requestParameters: AlbumApiGetAlbumInfoRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAlbumInfo(requestParameters.id, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiGetAllAlbumsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public getAllAlbums(requestParameters: AlbumApiGetAllAlbumsRequest = {}, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).getAllAlbums(requestParameters.shared, requestParameters.assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiRemoveAssetFromAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeAssetFromAlbum(requestParameters: AlbumApiRemoveAssetFromAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeAssetFromAlbum(requestParameters.id, requestParameters.removeAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiRemoveUserFromAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public removeUserFromAlbum(requestParameters: AlbumApiRemoveUserFromAlbumRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).removeUserFromAlbum(requestParameters.id, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumApiUpdateAlbumInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    public updateAlbumInfo(requestParameters: AlbumApiUpdateAlbumInfoRequest, options?: AxiosRequestConfig) {
        return AlbumApiFp(this.configuration).updateAlbumInfo(requestParameters.id, requestParameters.updateAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToSharedLink: async (addAssetsDto: AddAssetsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addAssetsDto' is not null or undefined
            assertParamExists('addAssetsToSharedLink', 'addAssetsDto', addAssetsDto)
            const localVarPath = `/asset/shared-link/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUploadCheck: async (assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetBulkUploadCheckDto' is not null or undefined
            assertParamExists('bulkUploadCheck', 'assetBulkUploadCheckDto', assetBulkUploadCheckDto)
            const localVarPath = `/asset/bulk-upload-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assetBulkUploadCheckDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset: async (checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkDuplicateAssetDto' is not null or undefined
            assertParamExists('checkDuplicateAsset', 'checkDuplicateAssetDto', checkDuplicateAssetDto)
            const localVarPath = `/asset/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkDuplicateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets: async (checkExistingAssetsDto: CheckExistingAssetsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkExistingAssetsDto' is not null or undefined
            assertParamExists('checkExistingAssets', 'checkExistingAssetsDto', checkExistingAssetsDto)
            const localVarPath = `/asset/exist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkExistingAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAssetsShareLinkDto} createAssetsShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetsSharedLink: async (createAssetsShareLinkDto: CreateAssetsShareLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAssetsShareLinkDto' is not null or undefined
            assertParamExists('createAssetsSharedLink', 'createAssetsShareLinkDto', createAssetsShareLinkDto)
            const localVarPath = `/asset/shared-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetsShareLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset: async (deleteAssetDto: DeleteAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAssetDto' is not null or undefined
            assertParamExists('deleteAsset', 'deleteAssetDto', deleteAssetDto)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (assetId: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('downloadFile', 'assetId', assetId)
            const localVarPath = `/asset/download/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DownloadFilesDto} downloadFilesDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFiles: async (downloadFilesDto: DownloadFilesDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadFilesDto' is not null or undefined
            assertParamExists('downloadFiles', 'downloadFilesDto', downloadFilesDto)
            const localVarPath = `/asset/download-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(downloadFilesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current this is not used in any UI element
         * @param {string} [name] 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLibrary: async (name?: string, skip?: number, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/download-library`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {number} [skip] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets: async (userId?: string, isFavorite?: boolean, isArchived?: boolean, skip?: number, ifNoneMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedAssetCountByUserId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/stat/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById: async (assetId: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetById', 'assetId', assetId)
            const localVarPath = `/asset/assetById/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByTimeBucket: async (getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAssetByTimeBucketDto' is not null or undefined
            assertParamExists('getAssetByTimeBucket', 'getAssetByTimeBucketDto', getAssetByTimeBucketDto)
            const localVarPath = `/asset/time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetByTimeBucketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeBucket: async (getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAssetCountByTimeBucketDto' is not null or undefined
            assertParamExists('getAssetCountByTimeBucket', 'getAssetCountByTimeBucketDto', getAssetCountByTimeBucketDto)
            const localVarPath = `/asset/count-by-time-bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetCountByTimeBucketDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByUserId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/count-by-user-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/search-terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail: async (assetId: string, format?: ThumbnailFormat, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetThumbnail', 'assetId', assetId)
            const localVarPath = `/asset/thumbnail/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/curated-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isFavorite] 
         * @param {string} [fileCreatedAfter] 
         * @param {string} [fileCreatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMarkers: async (isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/map-marker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (fileCreatedAfter !== undefined) {
                localVarQueryParameter['fileCreatedAfter'] = (fileCreatedAfter as any instanceof Date) ?
                    (fileCreatedAfter as any).toISOString() :
                    fileCreatedAfter;
            }

            if (fileCreatedBefore !== undefined) {
                localVarQueryParameter['fileCreatedBefore'] = (fileCreatedBefore as any instanceof Date) ?
                    (fileCreatedBefore as any).toISOString() :
                    fileCreatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId: async (deviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getUserAssetsByDeviceId', 'deviceId', deviceId)
            const localVarPath = `/asset/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetsFromSharedLink: async (removeAssetsDto: RemoveAssetsDto, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeAssetsDto' is not null or undefined
            assertParamExists('removeAssetsFromSharedLink', 'removeAssetsDto', removeAssetsDto)
            const localVarPath = `/asset/shared-link/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeAssetsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset: async (searchAssetDto: SearchAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchAssetDto' is not null or undefined
            assertParamExists('searchAsset', 'searchAssetDto', searchAssetDto)
            const localVarPath = `/asset/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile: async (assetId: string, isThumb?: boolean, isWeb?: boolean, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('serveFile', 'assetId', assetId)
            const localVarPath = `/asset/file/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }

            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (assetId: string, updateAssetDto: UpdateAssetDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateAsset', 'assetId', assetId)
            // verify required parameter 'updateAssetDto' is not null or undefined
            assertParamExists('updateAsset', 'updateAssetDto', updateAssetDto)
            const localVarPath = `/asset/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssetTypeEnum} assetType 
         * @param {File} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} fileExtension 
         * @param {string} [key] 
         * @param {File} [livePhotoData] 
         * @param {File} [sidecarData] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isVisible] 
         * @param {string} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (assetType: AssetTypeEnum, assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, fileExtension: string, key?: string, livePhotoData?: File, sidecarData?: File, isArchived?: boolean, isVisible?: boolean, duration?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetType' is not null or undefined
            assertParamExists('uploadFile', 'assetType', assetType)
            // verify required parameter 'assetData' is not null or undefined
            assertParamExists('uploadFile', 'assetData', assetData)
            // verify required parameter 'deviceAssetId' is not null or undefined
            assertParamExists('uploadFile', 'deviceAssetId', deviceAssetId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('uploadFile', 'deviceId', deviceId)
            // verify required parameter 'fileCreatedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileCreatedAt', fileCreatedAt)
            // verify required parameter 'fileModifiedAt' is not null or undefined
            assertParamExists('uploadFile', 'fileModifiedAt', fileModifiedAt)
            // verify required parameter 'isFavorite' is not null or undefined
            assertParamExists('uploadFile', 'isFavorite', isFavorite)
            // verify required parameter 'fileExtension' is not null or undefined
            assertParamExists('uploadFile', 'fileExtension', fileExtension)
            const localVarPath = `/asset/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


            if (assetType !== undefined) { 
                localVarFormParams.append('assetType', new Blob([JSON.stringify(assetType)], { type: "application/json", }));
            }
    
            if (assetData !== undefined) { 
                localVarFormParams.append('assetData', assetData as any);
            }
    
            if (livePhotoData !== undefined) { 
                localVarFormParams.append('livePhotoData', livePhotoData as any);
            }
    
            if (sidecarData !== undefined) { 
                localVarFormParams.append('sidecarData', sidecarData as any);
            }
    
            if (deviceAssetId !== undefined) { 
                localVarFormParams.append('deviceAssetId', deviceAssetId as any);
            }
    
            if (deviceId !== undefined) { 
                localVarFormParams.append('deviceId', deviceId as any);
            }
    
            if (fileCreatedAt !== undefined) { 
                localVarFormParams.append('fileCreatedAt', fileCreatedAt as any);
            }
    
            if (fileModifiedAt !== undefined) { 
                localVarFormParams.append('fileModifiedAt', fileModifiedAt as any);
            }
    
            if (isFavorite !== undefined) { 
                localVarFormParams.append('isFavorite', isFavorite as any);
            }
    
            if (isArchived !== undefined) { 
                localVarFormParams.append('isArchived', isArchived as any);
            }
    
            if (isVisible !== undefined) { 
                localVarFormParams.append('isVisible', isVisible as any);
            }
    
            if (fileExtension !== undefined) { 
                localVarFormParams.append('fileExtension', fileExtension as any);
            }
    
            if (duration !== undefined) { 
                localVarFormParams.append('duration', duration as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToSharedLink(addAssetsDto: AddAssetsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToSharedLink(addAssetsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUploadCheck(assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetBulkUploadCheckResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUploadCheck(assetBulkUploadCheckDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckDuplicateAssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDuplicateAsset(checkDuplicateAssetDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckExistingAssetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkExistingAssets(checkExistingAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateAssetsShareLinkDto} createAssetsShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssetsSharedLink(createAssetsShareLinkDto: CreateAssetsShareLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssetsSharedLink(createAssetsShareLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsset(deleteAssetDto: DeleteAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeleteAssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(deleteAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(assetId: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(assetId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DownloadFilesDto} downloadFilesDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFiles(downloadFilesDto: DownloadFilesDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFiles(downloadFilesDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Current this is not used in any UI element
         * @param {string} [name] 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLibrary(name?: string, skip?: number, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLibrary(name, skip, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {number} [skip] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssets(userId?: string, isFavorite?: boolean, isArchived?: boolean, skip?: number, ifNoneMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(userId, isFavorite, isArchived, skip, ifNoneMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArchivedAssetCountByUserId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetCountByUserIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArchivedAssetCountByUserId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetById(assetId: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetById(assetId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetByTimeBucket(getAssetByTimeBucketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetCountByTimeBucketResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetCountByUserId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetCountByUserIdResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetCountByUserId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetSearchTerms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetSearchTerms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetThumbnail(assetId: string, format?: ThumbnailFormat, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetThumbnail(assetId, format, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedLocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedLocationsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedObjects(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CuratedObjectsResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedObjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [isFavorite] 
         * @param {string} [fileCreatedAfter] 
         * @param {string} [fileCreatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMapMarkers(isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MapMarkerResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMapMarkers(isFavorite, fileCreatedAfter, fileCreatedBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssetsByDeviceId(deviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssetsByDeviceId(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetsFromSharedLink(removeAssetsDto: RemoveAssetsDto, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetsFromSharedLink(removeAssetsDto, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAsset(searchAssetDto: SearchAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAsset(searchAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveFile(assetId, isThumb, isWeb, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(assetId, updateAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AssetTypeEnum} assetType 
         * @param {File} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} fileExtension 
         * @param {string} [key] 
         * @param {File} [livePhotoData] 
         * @param {File} [sidecarData] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isVisible] 
         * @param {string} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(assetType: AssetTypeEnum, assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, fileExtension: string, key?: string, livePhotoData?: File, sidecarData?: File, isArchived?: boolean, isVisible?: boolean, duration?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFileUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(assetType, assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, fileExtension, key, livePhotoData, sidecarData, isArchived, isVisible, duration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         * 
         * @param {AddAssetsDto} addAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToSharedLink(addAssetsDto: AddAssetsDto, key?: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.addAssetsToSharedLink(addAssetsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if assets exist by checksums
         * @param {AssetBulkUploadCheckDto} assetBulkUploadCheckDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUploadCheck(assetBulkUploadCheckDto: AssetBulkUploadCheckDto, options?: any): AxiosPromise<AssetBulkUploadCheckResponseDto> {
            return localVarFp.bulkUploadCheck(assetBulkUploadCheckDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset(checkDuplicateAssetDto: CheckDuplicateAssetDto, key?: string, options?: any): AxiosPromise<CheckDuplicateAssetResponseDto> {
            return localVarFp.checkDuplicateAsset(checkDuplicateAssetDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if multiple assets exist on the server and returns all existing - used by background backup
         * @param {CheckExistingAssetsDto} checkExistingAssetsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExistingAssets(checkExistingAssetsDto: CheckExistingAssetsDto, options?: any): AxiosPromise<CheckExistingAssetsResponseDto> {
            return localVarFp.checkExistingAssets(checkExistingAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateAssetsShareLinkDto} createAssetsShareLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetsSharedLink(createAssetsShareLinkDto: CreateAssetsShareLinkDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.createAssetsSharedLink(createAssetsShareLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteAssetDto} deleteAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(deleteAssetDto: DeleteAssetDto, options?: any): AxiosPromise<Array<DeleteAssetResponseDto>> {
            return localVarFp.deleteAsset(deleteAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(assetId: string, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadFile(assetId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DownloadFilesDto} downloadFilesDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFiles(downloadFilesDto: DownloadFilesDto, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadFiles(downloadFilesDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Current this is not used in any UI element
         * @param {string} [name] 
         * @param {number} [skip] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLibrary(name?: string, skip?: number, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadLibrary(name, skip, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all AssetEntity belong to the user
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {number} [skip] 
         * @param {string} [ifNoneMatch] ETag of data already cached on the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets(userId?: string, isFavorite?: boolean, isArchived?: boolean, skip?: number, ifNoneMatch?: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAllAssets(userId, isFavorite, isArchived, skip, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedAssetCountByUserId(options?: any): AxiosPromise<AssetCountByUserIdResponseDto> {
            return localVarFp.getArchivedAssetCountByUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single asset\'s information
         * @param {string} assetId 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById(assetId: string, key?: string, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.getAssetById(assetId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAssetByTimeBucketDto} getAssetByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetByTimeBucket(getAssetByTimeBucketDto: GetAssetByTimeBucketDto, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getAssetByTimeBucket(getAssetByTimeBucketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetAssetCountByTimeBucketDto} getAssetCountByTimeBucketDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeBucket(getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto, options?: any): AxiosPromise<AssetCountByTimeBucketResponseDto> {
            return localVarFp.getAssetCountByTimeBucket(getAssetCountByTimeBucketDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByUserId(options?: any): AxiosPromise<AssetCountByUserIdResponseDto> {
            return localVarFp.getAssetCountByUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAssetSearchTerms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {ThumbnailFormat} [format] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail(assetId: string, format?: ThumbnailFormat, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.getAssetThumbnail(assetId, format, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations(options?: any): AxiosPromise<Array<CuratedLocationsResponseDto>> {
            return localVarFp.getCuratedLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects(options?: any): AxiosPromise<Array<CuratedObjectsResponseDto>> {
            return localVarFp.getCuratedObjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isFavorite] 
         * @param {string} [fileCreatedAfter] 
         * @param {string} [fileCreatedBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMarkers(isFavorite?: boolean, fileCreatedAfter?: string, fileCreatedBefore?: string, options?: any): AxiosPromise<Array<MapMarkerResponseDto>> {
            return localVarFp.getMapMarkers(isFavorite, fileCreatedAfter, fileCreatedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId(deviceId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getUserAssetsByDeviceId(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RemoveAssetsDto} removeAssetsDto 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetsFromSharedLink(removeAssetsDto: RemoveAssetsDto, key?: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.removeAssetsFromSharedLink(removeAssetsDto, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchAssetDto} searchAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset(searchAssetDto: SearchAssetDto, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.searchAsset(searchAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} assetId 
         * @param {boolean} [isThumb] 
         * @param {boolean} [isWeb] 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile(assetId: string, isThumb?: boolean, isWeb?: boolean, key?: string, options?: any): AxiosPromise<File> {
            return localVarFp.serveFile(assetId, isThumb, isWeb, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an asset
         * @param {string} assetId 
         * @param {UpdateAssetDto} updateAssetDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(assetId: string, updateAssetDto: UpdateAssetDto, options?: any): AxiosPromise<AssetResponseDto> {
            return localVarFp.updateAsset(assetId, updateAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AssetTypeEnum} assetType 
         * @param {File} assetData 
         * @param {string} deviceAssetId 
         * @param {string} deviceId 
         * @param {string} fileCreatedAt 
         * @param {string} fileModifiedAt 
         * @param {boolean} isFavorite 
         * @param {string} fileExtension 
         * @param {string} [key] 
         * @param {File} [livePhotoData] 
         * @param {File} [sidecarData] 
         * @param {boolean} [isArchived] 
         * @param {boolean} [isVisible] 
         * @param {string} [duration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(assetType: AssetTypeEnum, assetData: File, deviceAssetId: string, deviceId: string, fileCreatedAt: string, fileModifiedAt: string, isFavorite: boolean, fileExtension: string, key?: string, livePhotoData?: File, sidecarData?: File, isArchived?: boolean, isVisible?: boolean, duration?: string, options?: any): AxiosPromise<AssetFileUploadResponseDto> {
            return localVarFp.uploadFile(assetType, assetData, deviceAssetId, deviceId, fileCreatedAt, fileModifiedAt, isFavorite, fileExtension, key, livePhotoData, sidecarData, isArchived, isVisible, duration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addAssetsToSharedLink operation in AssetApi.
 * @export
 * @interface AssetApiAddAssetsToSharedLinkRequest
 */
export interface AssetApiAddAssetsToSharedLinkRequest {
    /**
     * 
     * @type {AddAssetsDto}
     * @memberof AssetApiAddAssetsToSharedLink
     */
    readonly addAssetsDto: AddAssetsDto

    /**
     * 
     * @type {string}
     * @memberof AssetApiAddAssetsToSharedLink
     */
    readonly key?: string
}

/**
 * Request parameters for bulkUploadCheck operation in AssetApi.
 * @export
 * @interface AssetApiBulkUploadCheckRequest
 */
export interface AssetApiBulkUploadCheckRequest {
    /**
     * 
     * @type {AssetBulkUploadCheckDto}
     * @memberof AssetApiBulkUploadCheck
     */
    readonly assetBulkUploadCheckDto: AssetBulkUploadCheckDto
}

/**
 * Request parameters for checkDuplicateAsset operation in AssetApi.
 * @export
 * @interface AssetApiCheckDuplicateAssetRequest
 */
export interface AssetApiCheckDuplicateAssetRequest {
    /**
     * 
     * @type {CheckDuplicateAssetDto}
     * @memberof AssetApiCheckDuplicateAsset
     */
    readonly checkDuplicateAssetDto: CheckDuplicateAssetDto

    /**
     * 
     * @type {string}
     * @memberof AssetApiCheckDuplicateAsset
     */
    readonly key?: string
}

/**
 * Request parameters for checkExistingAssets operation in AssetApi.
 * @export
 * @interface AssetApiCheckExistingAssetsRequest
 */
export interface AssetApiCheckExistingAssetsRequest {
    /**
     * 
     * @type {CheckExistingAssetsDto}
     * @memberof AssetApiCheckExistingAssets
     */
    readonly checkExistingAssetsDto: CheckExistingAssetsDto
}

/**
 * Request parameters for createAssetsSharedLink operation in AssetApi.
 * @export
 * @interface AssetApiCreateAssetsSharedLinkRequest
 */
export interface AssetApiCreateAssetsSharedLinkRequest {
    /**
     * 
     * @type {CreateAssetsShareLinkDto}
     * @memberof AssetApiCreateAssetsSharedLink
     */
    readonly createAssetsShareLinkDto: CreateAssetsShareLinkDto
}

/**
 * Request parameters for deleteAsset operation in AssetApi.
 * @export
 * @interface AssetApiDeleteAssetRequest
 */
export interface AssetApiDeleteAssetRequest {
    /**
     * 
     * @type {DeleteAssetDto}
     * @memberof AssetApiDeleteAsset
     */
    readonly deleteAssetDto: DeleteAssetDto
}

/**
 * Request parameters for downloadFile operation in AssetApi.
 * @export
 * @interface AssetApiDownloadFileRequest
 */
export interface AssetApiDownloadFileRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiDownloadFile
     */
    readonly assetId: string

    /**
     * 
     * @type {string}
     * @memberof AssetApiDownloadFile
     */
    readonly key?: string
}

/**
 * Request parameters for downloadFiles operation in AssetApi.
 * @export
 * @interface AssetApiDownloadFilesRequest
 */
export interface AssetApiDownloadFilesRequest {
    /**
     * 
     * @type {DownloadFilesDto}
     * @memberof AssetApiDownloadFiles
     */
    readonly downloadFilesDto: DownloadFilesDto

    /**
     * 
     * @type {string}
     * @memberof AssetApiDownloadFiles
     */
    readonly key?: string
}

/**
 * Request parameters for downloadLibrary operation in AssetApi.
 * @export
 * @interface AssetApiDownloadLibraryRequest
 */
export interface AssetApiDownloadLibraryRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiDownloadLibrary
     */
    readonly name?: string

    /**
     * 
     * @type {number}
     * @memberof AssetApiDownloadLibrary
     */
    readonly skip?: number

    /**
     * 
     * @type {string}
     * @memberof AssetApiDownloadLibrary
     */
    readonly key?: string
}

/**
 * Request parameters for getAllAssets operation in AssetApi.
 * @export
 * @interface AssetApiGetAllAssetsRequest
 */
export interface AssetApiGetAllAssetsRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiGetAllAssets
     */
    readonly userId?: string

    /**
     * 
     * @type {boolean}
     * @memberof AssetApiGetAllAssets
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AssetApiGetAllAssets
     */
    readonly isArchived?: boolean

    /**
     * 
     * @type {number}
     * @memberof AssetApiGetAllAssets
     */
    readonly skip?: number

    /**
     * ETag of data already cached on the client
     * @type {string}
     * @memberof AssetApiGetAllAssets
     */
    readonly ifNoneMatch?: string
}

/**
 * Request parameters for getAssetById operation in AssetApi.
 * @export
 * @interface AssetApiGetAssetByIdRequest
 */
export interface AssetApiGetAssetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiGetAssetById
     */
    readonly assetId: string

    /**
     * 
     * @type {string}
     * @memberof AssetApiGetAssetById
     */
    readonly key?: string
}

/**
 * Request parameters for getAssetByTimeBucket operation in AssetApi.
 * @export
 * @interface AssetApiGetAssetByTimeBucketRequest
 */
export interface AssetApiGetAssetByTimeBucketRequest {
    /**
     * 
     * @type {GetAssetByTimeBucketDto}
     * @memberof AssetApiGetAssetByTimeBucket
     */
    readonly getAssetByTimeBucketDto: GetAssetByTimeBucketDto
}

/**
 * Request parameters for getAssetCountByTimeBucket operation in AssetApi.
 * @export
 * @interface AssetApiGetAssetCountByTimeBucketRequest
 */
export interface AssetApiGetAssetCountByTimeBucketRequest {
    /**
     * 
     * @type {GetAssetCountByTimeBucketDto}
     * @memberof AssetApiGetAssetCountByTimeBucket
     */
    readonly getAssetCountByTimeBucketDto: GetAssetCountByTimeBucketDto
}

/**
 * Request parameters for getAssetThumbnail operation in AssetApi.
 * @export
 * @interface AssetApiGetAssetThumbnailRequest
 */
export interface AssetApiGetAssetThumbnailRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiGetAssetThumbnail
     */
    readonly assetId: string

    /**
     * 
     * @type {ThumbnailFormat}
     * @memberof AssetApiGetAssetThumbnail
     */
    readonly format?: ThumbnailFormat

    /**
     * 
     * @type {string}
     * @memberof AssetApiGetAssetThumbnail
     */
    readonly key?: string
}

/**
 * Request parameters for getMapMarkers operation in AssetApi.
 * @export
 * @interface AssetApiGetMapMarkersRequest
 */
export interface AssetApiGetMapMarkersRequest {
    /**
     * 
     * @type {boolean}
     * @memberof AssetApiGetMapMarkers
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof AssetApiGetMapMarkers
     */
    readonly fileCreatedAfter?: string

    /**
     * 
     * @type {string}
     * @memberof AssetApiGetMapMarkers
     */
    readonly fileCreatedBefore?: string
}

/**
 * Request parameters for getUserAssetsByDeviceId operation in AssetApi.
 * @export
 * @interface AssetApiGetUserAssetsByDeviceIdRequest
 */
export interface AssetApiGetUserAssetsByDeviceIdRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiGetUserAssetsByDeviceId
     */
    readonly deviceId: string
}

/**
 * Request parameters for removeAssetsFromSharedLink operation in AssetApi.
 * @export
 * @interface AssetApiRemoveAssetsFromSharedLinkRequest
 */
export interface AssetApiRemoveAssetsFromSharedLinkRequest {
    /**
     * 
     * @type {RemoveAssetsDto}
     * @memberof AssetApiRemoveAssetsFromSharedLink
     */
    readonly removeAssetsDto: RemoveAssetsDto

    /**
     * 
     * @type {string}
     * @memberof AssetApiRemoveAssetsFromSharedLink
     */
    readonly key?: string
}

/**
 * Request parameters for searchAsset operation in AssetApi.
 * @export
 * @interface AssetApiSearchAssetRequest
 */
export interface AssetApiSearchAssetRequest {
    /**
     * 
     * @type {SearchAssetDto}
     * @memberof AssetApiSearchAsset
     */
    readonly searchAssetDto: SearchAssetDto
}

/**
 * Request parameters for serveFile operation in AssetApi.
 * @export
 * @interface AssetApiServeFileRequest
 */
export interface AssetApiServeFileRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiServeFile
     */
    readonly assetId: string

    /**
     * 
     * @type {boolean}
     * @memberof AssetApiServeFile
     */
    readonly isThumb?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AssetApiServeFile
     */
    readonly isWeb?: boolean

    /**
     * 
     * @type {string}
     * @memberof AssetApiServeFile
     */
    readonly key?: string
}

/**
 * Request parameters for updateAsset operation in AssetApi.
 * @export
 * @interface AssetApiUpdateAssetRequest
 */
export interface AssetApiUpdateAssetRequest {
    /**
     * 
     * @type {string}
     * @memberof AssetApiUpdateAsset
     */
    readonly assetId: string

    /**
     * 
     * @type {UpdateAssetDto}
     * @memberof AssetApiUpdateAsset
     */
    readonly updateAssetDto: UpdateAssetDto
}

/**
 * Request parameters for uploadFile operation in AssetApi.
 * @export
 * @interface AssetApiUploadFileRequest
 */
export interface AssetApiUploadFileRequest {
    /**
     * 
     * @type {AssetTypeEnum}
     * @memberof AssetApiUploadFile
     */
    readonly assetType: AssetTypeEnum

    /**
     * 
     * @type {File}
     * @memberof AssetApiUploadFile
     */
    readonly assetData: File

    /**
     * 
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly deviceAssetId: string

    /**
     * 
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly deviceId: string

    /**
     * 
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly fileCreatedAt: string

    /**
     * 
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly fileModifiedAt: string

    /**
     * 
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isFavorite: boolean

    /**
     * 
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly fileExtension: string

    /**
     * 
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly key?: string

    /**
     * 
     * @type {File}
     * @memberof AssetApiUploadFile
     */
    readonly livePhotoData?: File

    /**
     * 
     * @type {File}
     * @memberof AssetApiUploadFile
     */
    readonly sidecarData?: File

    /**
     * 
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isArchived?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AssetApiUploadFile
     */
    readonly isVisible?: boolean

    /**
     * 
     * @type {string}
     * @memberof AssetApiUploadFile
     */
    readonly duration?: string
}

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * 
     * @param {AssetApiAddAssetsToSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public addAssetsToSharedLink(requestParameters: AssetApiAddAssetsToSharedLinkRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).addAssetsToSharedLink(requestParameters.addAssetsDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if assets exist by checksums
     * @param {AssetApiBulkUploadCheckRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public bulkUploadCheck(requestParameters: AssetApiBulkUploadCheckRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).bulkUploadCheck(requestParameters.assetBulkUploadCheckDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check duplicated asset before uploading - for Web upload used
     * @param {AssetApiCheckDuplicateAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkDuplicateAsset(requestParameters: AssetApiCheckDuplicateAssetRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkDuplicateAsset(requestParameters.checkDuplicateAssetDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if multiple assets exist on the server and returns all existing - used by background backup
     * @param {AssetApiCheckExistingAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public checkExistingAssets(requestParameters: AssetApiCheckExistingAssetsRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).checkExistingAssets(requestParameters.checkExistingAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiCreateAssetsSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public createAssetsSharedLink(requestParameters: AssetApiCreateAssetsSharedLinkRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).createAssetsSharedLink(requestParameters.createAssetsShareLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiDeleteAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAsset(requestParameters: AssetApiDeleteAssetRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).deleteAsset(requestParameters.deleteAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiDownloadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadFile(requestParameters: AssetApiDownloadFileRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadFile(requestParameters.assetId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiDownloadFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadFiles(requestParameters: AssetApiDownloadFilesRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadFiles(requestParameters.downloadFilesDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current this is not used in any UI element
     * @param {AssetApiDownloadLibraryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public downloadLibrary(requestParameters: AssetApiDownloadLibraryRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).downloadLibrary(requestParameters.name, requestParameters.skip, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all AssetEntity belong to the user
     * @param {AssetApiGetAllAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAllAssets(requestParameters: AssetApiGetAllAssetsRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAllAssets(requestParameters.userId, requestParameters.isFavorite, requestParameters.isArchived, requestParameters.skip, requestParameters.ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getArchivedAssetCountByUserId(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getArchivedAssetCountByUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single asset\'s information
     * @param {AssetApiGetAssetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetById(requestParameters: AssetApiGetAssetByIdRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetById(requestParameters.assetId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiGetAssetByTimeBucketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetByTimeBucket(requestParameters: AssetApiGetAssetByTimeBucketRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetByTimeBucket(requestParameters.getAssetByTimeBucketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiGetAssetCountByTimeBucketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetCountByTimeBucket(requestParameters: AssetApiGetAssetCountByTimeBucketRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetCountByTimeBucket(requestParameters.getAssetCountByTimeBucketDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetCountByUserId(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetCountByUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetSearchTerms(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetSearchTerms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiGetAssetThumbnailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssetThumbnail(requestParameters: AssetApiGetAssetThumbnailRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAssetThumbnail(requestParameters.assetId, requestParameters.format, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedLocations(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getCuratedObjects(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getCuratedObjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiGetMapMarkersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getMapMarkers(requestParameters: AssetApiGetMapMarkersRequest = {}, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getMapMarkers(requestParameters.isFavorite, requestParameters.fileCreatedAfter, requestParameters.fileCreatedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all asset of a device that are in the database, ID only.
     * @param {AssetApiGetUserAssetsByDeviceIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getUserAssetsByDeviceId(requestParameters: AssetApiGetUserAssetsByDeviceIdRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getUserAssetsByDeviceId(requestParameters.deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiRemoveAssetsFromSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public removeAssetsFromSharedLink(requestParameters: AssetApiRemoveAssetsFromSharedLinkRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).removeAssetsFromSharedLink(requestParameters.removeAssetsDto, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiSearchAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public searchAsset(requestParameters: AssetApiSearchAssetRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).searchAsset(requestParameters.searchAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiServeFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public serveFile(requestParameters: AssetApiServeFileRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).serveFile(requestParameters.assetId, requestParameters.isThumb, requestParameters.isWeb, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an asset
     * @param {AssetApiUpdateAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(requestParameters: AssetApiUpdateAssetRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAsset(requestParameters.assetId, requestParameters.updateAssetDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssetApiUploadFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public uploadFile(requestParameters: AssetApiUploadFileRequest, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).uploadFile(requestParameters.assetType, requestParameters.assetData, requestParameters.deviceAssetId, requestParameters.deviceId, requestParameters.fileCreatedAt, requestParameters.fileModifiedAt, requestParameters.isFavorite, requestParameters.fileExtension, requestParameters.key, requestParameters.livePhotoData, requestParameters.sidecarData, requestParameters.isArchived, requestParameters.isVisible, requestParameters.duration, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp: async (signUpDto: SignUpDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('adminSignUp', 'signUpDto', signUpDto)
            const localVarPath = `/auth/admin-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDto: ChangePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginCredentialDto: LoginCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCredentialDto' is not null or undefined
            assertParamExists('login', 'loginCredentialDto', loginCredentialDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevice: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logoutAuthDevice', 'id', id)
            const localVarPath = `/auth/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validateToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSignUp(signUpDto: SignUpDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSignupResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSignUp(signUpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthDeviceResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginCredentialDto: LoginCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthDevice(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthDevices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthDevices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAccessToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAccessTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp(signUpDto: SignUpDto, options?: any): AxiosPromise<AdminSignupResponseDto> {
            return localVarFp.adminSignUp(signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.changePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthDevices(options?: any): AxiosPromise<Array<AuthDeviceResponseDto>> {
            return localVarFp.getAuthDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginCredentialDto} loginCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginCredentialDto: LoginCredentialDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.login(loginCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<LogoutResponseDto> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevice(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.logoutAuthDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthDevices(options?: any): AxiosPromise<void> {
            return localVarFp.logoutAuthDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken(options?: any): AxiosPromise<ValidateAccessTokenResponseDto> {
            return localVarFp.validateAccessToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for adminSignUp operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiAdminSignUpRequest
 */
export interface AuthenticationApiAdminSignUpRequest {
    /**
     * 
     * @type {SignUpDto}
     * @memberof AuthenticationApiAdminSignUp
     */
    readonly signUpDto: SignUpDto
}

/**
 * Request parameters for changePassword operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiChangePasswordRequest
 */
export interface AuthenticationApiChangePasswordRequest {
    /**
     * 
     * @type {ChangePasswordDto}
     * @memberof AuthenticationApiChangePassword
     */
    readonly changePasswordDto: ChangePasswordDto
}

/**
 * Request parameters for login operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiLoginRequest
 */
export interface AuthenticationApiLoginRequest {
    /**
     * 
     * @type {LoginCredentialDto}
     * @memberof AuthenticationApiLogin
     */
    readonly loginCredentialDto: LoginCredentialDto
}

/**
 * Request parameters for logoutAuthDevice operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiLogoutAuthDeviceRequest
 */
export interface AuthenticationApiLogoutAuthDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationApiLogoutAuthDevice
     */
    readonly id: string
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {AuthenticationApiAdminSignUpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public adminSignUp(requestParameters: AuthenticationApiAdminSignUpRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).adminSignUp(requestParameters.signUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthenticationApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(requestParameters: AuthenticationApiChangePasswordRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePassword(requestParameters.changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthDevices(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAuthDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(requestParameters: AuthenticationApiLoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(requestParameters.loginCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthenticationApiLogoutAuthDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutAuthDevice(requestParameters: AuthenticationApiLogoutAuthDeviceRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutAuthDevice(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutAuthDevices(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutAuthDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public validateAccessToken(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateAccessToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {JobName} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand: async (jobId: JobName, jobCommandDto: JobCommandDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('sendJobCommand', 'jobId', jobId)
            // verify required parameter 'jobCommandDto' is not null or undefined
            assertParamExists('sendJobCommand', 'jobCommandDto', jobCommandDto)
            const localVarPath = `/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllJobsStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllJobStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllJobsStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {JobName} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendJobCommand(jobId: JobName, jobCommandDto: JobCommandDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendJobCommand(jobId, jobCommandDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllJobsStatus(options?: any): AxiosPromise<AllJobStatusResponseDto> {
            return localVarFp.getAllJobsStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {JobName} jobId 
         * @param {JobCommandDto} jobCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendJobCommand(jobId: JobName, jobCommandDto: JobCommandDto, options?: any): AxiosPromise<JobStatusDto> {
            return localVarFp.sendJobCommand(jobId, jobCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for sendJobCommand operation in JobApi.
 * @export
 * @interface JobApiSendJobCommandRequest
 */
export interface JobApiSendJobCommandRequest {
    /**
     * 
     * @type {JobName}
     * @memberof JobApiSendJobCommand
     */
    readonly jobId: JobName

    /**
     * 
     * @type {JobCommandDto}
     * @memberof JobApiSendJobCommand
     */
    readonly jobCommandDto: JobCommandDto
}

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getAllJobsStatus(options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).getAllJobsStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {JobApiSendJobCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public sendJobCommand(requestParameters: JobApiSendJobCommandRequest, options?: AxiosRequestConfig) {
        return JobApiFp(this.configuration).sendJobCommand(requestParameters.jobId, requestParameters.jobCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('callback', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateConfig: async (oAuthConfigDto: OAuthConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthConfigDto' is not null or undefined
            assertParamExists('generateConfig', 'oAuthConfigDto', oAuthConfigDto)
            const localVarPath = `/oauth/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link: async (oAuthCallbackDto: OAuthCallbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthCallbackDto' is not null or undefined
            assertParamExists('link', 'oAuthCallbackDto', oAuthCallbackDto)
            const localVarPath = `/oauth/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthCallbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileRedirect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/mobile-redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/unlink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateConfig(oAuthConfigDto: OAuthConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateConfig(oAuthConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async link(oAuthCallbackDto: OAuthCallbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.link(oAuthCallbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mobileRedirect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mobileRedirect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlink(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlink(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(oAuthCallbackDto: OAuthCallbackDto, options?: any): AxiosPromise<LoginResponseDto> {
            return localVarFp.callback(oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthConfigDto} oAuthConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateConfig(oAuthConfigDto: OAuthConfigDto, options?: any): AxiosPromise<OAuthConfigResponseDto> {
            return localVarFp.generateConfig(oAuthConfigDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OAuthCallbackDto} oAuthCallbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link(oAuthCallbackDto: OAuthCallbackDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.link(oAuthCallbackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileRedirect(options?: any): AxiosPromise<void> {
            return localVarFp.mobileRedirect(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink(options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.unlink(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for callback operation in OAuthApi.
 * @export
 * @interface OAuthApiCallbackRequest
 */
export interface OAuthApiCallbackRequest {
    /**
     * 
     * @type {OAuthCallbackDto}
     * @memberof OAuthApiCallback
     */
    readonly oAuthCallbackDto: OAuthCallbackDto
}

/**
 * Request parameters for generateConfig operation in OAuthApi.
 * @export
 * @interface OAuthApiGenerateConfigRequest
 */
export interface OAuthApiGenerateConfigRequest {
    /**
     * 
     * @type {OAuthConfigDto}
     * @memberof OAuthApiGenerateConfig
     */
    readonly oAuthConfigDto: OAuthConfigDto
}

/**
 * Request parameters for link operation in OAuthApi.
 * @export
 * @interface OAuthApiLinkRequest
 */
export interface OAuthApiLinkRequest {
    /**
     * 
     * @type {OAuthCallbackDto}
     * @memberof OAuthApiLink
     */
    readonly oAuthCallbackDto: OAuthCallbackDto
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * 
     * @param {OAuthApiCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public callback(requestParameters: OAuthApiCallbackRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).callback(requestParameters.oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthApiGenerateConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public generateConfig(requestParameters: OAuthApiGenerateConfigRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).generateConfig(requestParameters.oAuthConfigDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OAuthApiLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public link(requestParameters: OAuthApiLinkRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).link(requestParameters.oAuthCallbackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public mobileRedirect(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).mobileRedirect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public unlink(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).unlink(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartnerApi - axios parameter creator
 * @export
 */
export const PartnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPartner', 'id', id)
            const localVarPath = `/partner/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'shared-by' | 'shared-with'} direction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners: async (direction: 'shared-by' | 'shared-with', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'direction' is not null or undefined
            assertParamExists('getPartners', 'direction', direction)
            const localVarPath = `/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePartner: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removePartner', 'id', id)
            const localVarPath = `/partner/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerApi - functional programming interface
 * @export
 */
export const PartnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPartner(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPartner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'shared-by' | 'shared-with'} direction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartners(direction: 'shared-by' | 'shared-with', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartners(direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePartner(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePartner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartnerApi - factory interface
 * @export
 */
export const PartnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartner(id: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.createPartner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'shared-by' | 'shared-with'} direction 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartners(direction: 'shared-by' | 'shared-with', options?: any): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.getPartners(direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePartner(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removePartner(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPartner operation in PartnerApi.
 * @export
 * @interface PartnerApiCreatePartnerRequest
 */
export interface PartnerApiCreatePartnerRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerApiCreatePartner
     */
    readonly id: string
}

/**
 * Request parameters for getPartners operation in PartnerApi.
 * @export
 * @interface PartnerApiGetPartnersRequest
 */
export interface PartnerApiGetPartnersRequest {
    /**
     * 
     * @type {'shared-by' | 'shared-with'}
     * @memberof PartnerApiGetPartners
     */
    readonly direction: 'shared-by' | 'shared-with'
}

/**
 * Request parameters for removePartner operation in PartnerApi.
 * @export
 * @interface PartnerApiRemovePartnerRequest
 */
export interface PartnerApiRemovePartnerRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerApiRemovePartner
     */
    readonly id: string
}

/**
 * PartnerApi - object-oriented interface
 * @export
 * @class PartnerApi
 * @extends {BaseAPI}
 */
export class PartnerApi extends BaseAPI {
    /**
     * 
     * @param {PartnerApiCreatePartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public createPartner(requestParameters: PartnerApiCreatePartnerRequest, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).createPartner(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerApiGetPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public getPartners(requestParameters: PartnerApiGetPartnersRequest, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).getPartners(requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartnerApiRemovePartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnerApi
     */
    public removePartner(requestParameters: PartnerApiRemovePartnerRequest, options?: AxiosRequestConfig) {
        return PartnerApiFp(this.configuration).removePartner(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonApi - axios parameter creator
 * @export
 */
export const PersonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPerson', 'id', id)
            const localVarPath = `/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonAssets: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonAssets', 'id', id)
            const localVarPath = `/person/{id}/assets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonThumbnail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonThumbnail', 'id', id)
            const localVarPath = `/person/{id}/thumbnail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PersonUpdateDto} personUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (id: string, personUpdateDto: PersonUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePerson', 'id', id)
            // verify required parameter 'personUpdateDto' is not null or undefined
            assertParamExists('updatePerson', 'personUpdateDto', personUpdateDto)
            const localVarPath = `/person/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonApi - functional programming interface
 * @export
 */
export const PersonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPeople(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPeople(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonAssets(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonAssets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonThumbnail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonThumbnail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {PersonUpdateDto} personUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(id: string, personUpdateDto: PersonUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(id, personUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonApi - factory interface
 * @export
 */
export const PersonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople(options?: any): AxiosPromise<Array<PersonResponseDto>> {
            return localVarFp.getAllPeople(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: string, options?: any): AxiosPromise<PersonResponseDto> {
            return localVarFp.getPerson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonAssets(id: string, options?: any): AxiosPromise<Array<AssetResponseDto>> {
            return localVarFp.getPersonAssets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonThumbnail(id: string, options?: any): AxiosPromise<File> {
            return localVarFp.getPersonThumbnail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PersonUpdateDto} personUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: string, personUpdateDto: PersonUpdateDto, options?: any): AxiosPromise<PersonResponseDto> {
            return localVarFp.updatePerson(id, personUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPerson operation in PersonApi.
 * @export
 * @interface PersonApiGetPersonRequest
 */
export interface PersonApiGetPersonRequest {
    /**
     * 
     * @type {string}
     * @memberof PersonApiGetPerson
     */
    readonly id: string
}

/**
 * Request parameters for getPersonAssets operation in PersonApi.
 * @export
 * @interface PersonApiGetPersonAssetsRequest
 */
export interface PersonApiGetPersonAssetsRequest {
    /**
     * 
     * @type {string}
     * @memberof PersonApiGetPersonAssets
     */
    readonly id: string
}

/**
 * Request parameters for getPersonThumbnail operation in PersonApi.
 * @export
 * @interface PersonApiGetPersonThumbnailRequest
 */
export interface PersonApiGetPersonThumbnailRequest {
    /**
     * 
     * @type {string}
     * @memberof PersonApiGetPersonThumbnail
     */
    readonly id: string
}

/**
 * Request parameters for updatePerson operation in PersonApi.
 * @export
 * @interface PersonApiUpdatePersonRequest
 */
export interface PersonApiUpdatePersonRequest {
    /**
     * 
     * @type {string}
     * @memberof PersonApiUpdatePerson
     */
    readonly id: string

    /**
     * 
     * @type {PersonUpdateDto}
     * @memberof PersonApiUpdatePerson
     */
    readonly personUpdateDto: PersonUpdateDto
}

/**
 * PersonApi - object-oriented interface
 * @export
 * @class PersonApi
 * @extends {BaseAPI}
 */
export class PersonApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getAllPeople(options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getAllPeople(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonApiGetPersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPerson(requestParameters: PersonApiGetPersonRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPerson(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonApiGetPersonAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPersonAssets(requestParameters: PersonApiGetPersonAssetsRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPersonAssets(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonApiGetPersonThumbnailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPersonThumbnail(requestParameters: PersonApiGetPersonThumbnailRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPersonThumbnail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonApiUpdatePersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public updatePerson(requestParameters: PersonApiUpdatePersonRequest, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).updatePerson(requestParameters.id, requestParameters.personUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, isArchived?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (clip !== undefined) {
                localVarQueryParameter['clip'] = clip;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isArchived !== undefined) {
                localVarQueryParameter['isArchived'] = isArchived;
            }

            if (exifInfoCity !== undefined) {
                localVarQueryParameter['exifInfo.city'] = exifInfoCity;
            }

            if (exifInfoState !== undefined) {
                localVarQueryParameter['exifInfo.state'] = exifInfoState;
            }

            if (exifInfoCountry !== undefined) {
                localVarQueryParameter['exifInfo.country'] = exifInfoCountry;
            }

            if (exifInfoMake !== undefined) {
                localVarQueryParameter['exifInfo.make'] = exifInfoMake;
            }

            if (exifInfoModel !== undefined) {
                localVarQueryParameter['exifInfo.model'] = exifInfoModel;
            }

            if (smartInfoObjects) {
                localVarQueryParameter['smartInfo.objects'] = smartInfoObjects;
            }

            if (smartInfoTags) {
                localVarQueryParameter['smartInfo.tags'] = smartInfoTags;
            }

            if (recent !== undefined) {
                localVarQueryParameter['recent'] = recent;
            }

            if (motion !== undefined) {
                localVarQueryParameter['motion'] = motion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExploreData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchExploreResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExploreData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchConfigResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, isArchived?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, query, clip, type, isFavorite, isArchived, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, smartInfoObjects, smartInfoTags, recent, motion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExploreData(options?: any): AxiosPromise<Array<SearchExploreResponseDto>> {
            return localVarFp.getExploreData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchConfig(options?: any): AxiosPromise<SearchConfigResponseDto> {
            return localVarFp.getSearchConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [q] 
         * @param {string} [query] 
         * @param {boolean} [clip] 
         * @param {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'} [type] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isArchived] 
         * @param {string} [exifInfoCity] 
         * @param {string} [exifInfoState] 
         * @param {string} [exifInfoCountry] 
         * @param {string} [exifInfoMake] 
         * @param {string} [exifInfoModel] 
         * @param {Array<string>} [smartInfoObjects] 
         * @param {Array<string>} [smartInfoTags] 
         * @param {boolean} [recent] 
         * @param {boolean} [motion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q?: string, query?: string, clip?: boolean, type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER', isFavorite?: boolean, isArchived?: boolean, exifInfoCity?: string, exifInfoState?: string, exifInfoCountry?: string, exifInfoMake?: string, exifInfoModel?: string, smartInfoObjects?: Array<string>, smartInfoTags?: Array<string>, recent?: boolean, motion?: boolean, options?: any): AxiosPromise<SearchResponseDto> {
            return localVarFp.search(q, query, clip, type, isFavorite, isArchived, exifInfoCity, exifInfoState, exifInfoCountry, exifInfoMake, exifInfoModel, smartInfoObjects, smartInfoTags, recent, motion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for search operation in SearchApi.
 * @export
 * @interface SearchApiSearchRequest
 */
export interface SearchApiSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly query?: string

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly clip?: boolean

    /**
     * 
     * @type {'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'}
     * @memberof SearchApiSearch
     */
    readonly type?: 'IMAGE' | 'VIDEO' | 'AUDIO' | 'OTHER'

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly isArchived?: boolean

    /**
     * 
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly exifInfoCity?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly exifInfoState?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly exifInfoCountry?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly exifInfoMake?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly exifInfoModel?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof SearchApiSearch
     */
    readonly smartInfoObjects?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof SearchApiSearch
     */
    readonly smartInfoTags?: Array<string>

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly recent?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiSearch
     */
    readonly motion?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getExploreData(options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).getExploreData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSearchConfig(options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).getSearchConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(requestParameters: SearchApiSearchRequest = {}, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(requestParameters.q, requestParameters.query, requestParameters.clip, requestParameters.type, requestParameters.isFavorite, requestParameters.isArchived, requestParameters.exifInfoCity, requestParameters.exifInfoState, requestParameters.exifInfoCountry, requestParameters.exifInfoMake, requestParameters.exifInfoModel, requestParameters.smartInfoObjects, requestParameters.smartInfoTags, requestParameters.recent, requestParameters.motion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerInfoApi - axios parameter creator
 * @export
 */
export const ServerInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server-info/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerInfoApi - functional programming interface
 * @export
 */
export const ServerInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerVersionReponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerStatsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingServer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerPingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingServer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerInfoApi - factory interface
 * @export
 */
export const ServerInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerInfoApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: any): AxiosPromise<ServerInfoResponseDto> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options?: any): AxiosPromise<ServerVersionReponseDto> {
            return localVarFp.getServerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<ServerStatsResponseDto> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options?: any): AxiosPromise<ServerPingResponse> {
            return localVarFp.pingServer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerInfoApi - object-oriented interface
 * @export
 * @class ServerInfoApi
 * @extends {BaseAPI}
 */
export class ServerInfoApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerInfo(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getServerVersion(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getServerVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public pingServer(options?: AxiosRequestConfig) {
        return ServerInfoApiFp(this.configuration).pingServer(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {EditSharedLinkDto} editSharedLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSharedLink: async (id: string, editSharedLinkDto: EditSharedLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editSharedLink', 'id', id)
            // verify required parameter 'editSharedLinkDto' is not null or undefined
            assertParamExists('editSharedLink', 'editSharedLinkDto', editSharedLinkDto)
            const localVarPath = `/share/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editSharedLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/share/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSharedLinkById', 'id', id)
            const localVarPath = `/share/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeSharedLink', 'id', id)
            const localVarPath = `/share/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {EditSharedLinkDto} editSharedLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editSharedLink(id: string, editSharedLinkDto: EditSharedLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editSharedLink(id, editSharedLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedLinks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedLinkResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedLinks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySharedLink(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySharedLink(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedLinkById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedLinkResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedLinkById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSharedLink(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSharedLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {EditSharedLinkDto} editSharedLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editSharedLink(id: string, editSharedLinkDto: EditSharedLinkDto, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.editSharedLink(id, editSharedLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedLinks(options?: any): AxiosPromise<Array<SharedLinkResponseDto>> {
            return localVarFp.getAllSharedLinks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySharedLink(key?: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getMySharedLink(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedLinkById(id: string, options?: any): AxiosPromise<SharedLinkResponseDto> {
            return localVarFp.getSharedLinkById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSharedLink(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeSharedLink(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for editSharedLink operation in ShareApi.
 * @export
 * @interface ShareApiEditSharedLinkRequest
 */
export interface ShareApiEditSharedLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof ShareApiEditSharedLink
     */
    readonly id: string

    /**
     * 
     * @type {EditSharedLinkDto}
     * @memberof ShareApiEditSharedLink
     */
    readonly editSharedLinkDto: EditSharedLinkDto
}

/**
 * Request parameters for getMySharedLink operation in ShareApi.
 * @export
 * @interface ShareApiGetMySharedLinkRequest
 */
export interface ShareApiGetMySharedLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof ShareApiGetMySharedLink
     */
    readonly key?: string
}

/**
 * Request parameters for getSharedLinkById operation in ShareApi.
 * @export
 * @interface ShareApiGetSharedLinkByIdRequest
 */
export interface ShareApiGetSharedLinkByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ShareApiGetSharedLinkById
     */
    readonly id: string
}

/**
 * Request parameters for removeSharedLink operation in ShareApi.
 * @export
 * @interface ShareApiRemoveSharedLinkRequest
 */
export interface ShareApiRemoveSharedLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof ShareApiRemoveSharedLink
     */
    readonly id: string
}

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @param {ShareApiEditSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public editSharedLink(requestParameters: ShareApiEditSharedLinkRequest, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).editSharedLink(requestParameters.id, requestParameters.editSharedLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getAllSharedLinks(options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).getAllSharedLinks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShareApiGetMySharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getMySharedLink(requestParameters: ShareApiGetMySharedLinkRequest = {}, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).getMySharedLink(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShareApiGetSharedLinkByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedLinkById(requestParameters: ShareApiGetSharedLinkByIdRequest, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).getSharedLinkById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShareApiRemoveSharedLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public removeSharedLink(requestParameters: ShareApiRemoveSharedLinkRequest, options?: AxiosRequestConfig) {
        return ShareApiFp(this.configuration).removeSharedLink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemConfigApi - axios parameter creator
 * @export
 */
export const SystemConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system-config/storage-template-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig: async (systemConfigDto: SystemConfigDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemConfigDto' is not null or undefined
            assertParamExists('updateConfig', 'systemConfigDto', systemConfigDto)
            const localVarPath = `/system-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemConfigDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemConfigApi - functional programming interface
 * @export
 */
export const SystemConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaults(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaults(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageTemplateOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigTemplateStorageOptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageTemplateOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfig(systemConfigDto: SystemConfigDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfig(systemConfigDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemConfigApi - factory interface
 * @export
 */
export const SystemConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaults(options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.getDefaults(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageTemplateOptions(options?: any): AxiosPromise<SystemConfigTemplateStorageOptionDto> {
            return localVarFp.getStorageTemplateOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SystemConfigDto} systemConfigDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfig(systemConfigDto: SystemConfigDto, options?: any): AxiosPromise<SystemConfigDto> {
            return localVarFp.updateConfig(systemConfigDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateConfig operation in SystemConfigApi.
 * @export
 * @interface SystemConfigApiUpdateConfigRequest
 */
export interface SystemConfigApiUpdateConfigRequest {
    /**
     * 
     * @type {SystemConfigDto}
     * @memberof SystemConfigApiUpdateConfig
     */
    readonly systemConfigDto: SystemConfigDto
}

/**
 * SystemConfigApi - object-oriented interface
 * @export
 * @class SystemConfigApi
 * @extends {BaseAPI}
 */
export class SystemConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getDefaults(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getDefaults(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public getStorageTemplateOptions(options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).getStorageTemplateOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SystemConfigApiUpdateConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigApi
     */
    public updateConfig(requestParameters: SystemConfigApiUpdateConfigRequest, options?: AxiosRequestConfig) {
        return SystemConfigApiFp(this.configuration).updateConfig(requestParameters.systemConfigDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createTagDto: CreateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTagDto' is not null or undefined
            assertParamExists('create', 'createTagDto', createTagDto)
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOne', 'id', id)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, updateTagDto: UpdateTagDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'updateTagDto' is not null or undefined
            assertParamExists('update', 'updateTagDto', updateTagDto)
            const localVarPath = `/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createTagDto: CreateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, updateTagDto: UpdateTagDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, updateTagDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTagDto} createTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createTagDto: CreateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.create(createTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: any): AxiosPromise<Array<TagResponseDto>> {
            return localVarFp.findAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOne(id: string, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.findOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTagDto} updateTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, updateTagDto: UpdateTagDto, options?: any): AxiosPromise<TagResponseDto> {
            return localVarFp.update(id, updateTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in TagApi.
 * @export
 * @interface TagApiDeleteRequest
 */
export interface TagApiDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TagApiDelete
     */
    readonly id: string
}

/**
 * Request parameters for create operation in TagApi.
 * @export
 * @interface TagApiCreateRequest
 */
export interface TagApiCreateRequest {
    /**
     * 
     * @type {CreateTagDto}
     * @memberof TagApiCreate
     */
    readonly createTagDto: CreateTagDto
}

/**
 * Request parameters for findOne operation in TagApi.
 * @export
 * @interface TagApiFindOneRequest
 */
export interface TagApiFindOneRequest {
    /**
     * 
     * @type {string}
     * @memberof TagApiFindOne
     */
    readonly id: string
}

/**
 * Request parameters for update operation in TagApi.
 * @export
 * @interface TagApiUpdateRequest
 */
export interface TagApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TagApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {UpdateTagDto}
     * @memberof TagApiUpdate
     */
    readonly updateTagDto: UpdateTagDto
}

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @param {TagApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public _delete(requestParameters: TagApiDeleteRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public create(requestParameters: TagApiCreateRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).create(requestParameters.createTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public findAll(options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).findAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagApiFindOneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public findOne(requestParameters: TagApiFindOneRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).findOne(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public update(requestParameters: TagApiUpdateRequest, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).update(requestParameters.id, requestParameters.updateTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createProfileImage', 'file', file)
            const localVarPath = `/user/profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('createUser', 'createUserDto', createUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (isAll: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isAll' is not null or undefined
            assertParamExists('getAllUsers', 'isAll', isAll)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isAll !== undefined) {
                localVarQueryParameter['isAll'] = isAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProfileImage', 'userId', userId)
            const localVarPath = `/user/profile-image/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/user/info/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('restoreUser', 'userId', userId)
            const localVarPath = `/user/{userId}/restore`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileImage(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProfileImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(isAll: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(isAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileImage(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileImage(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCount(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCount(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage(file: File, options?: any): AxiosPromise<CreateProfileImageResponseDto> {
            return localVarFp.createProfileImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserDto: CreateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.createUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} isAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(isAll: boolean, options?: any): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.getAllUsers(isAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo(options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getMyUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage(userId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getProfileImage(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount(admin?: boolean, options?: any): AxiosPromise<UserCountResponseDto> {
            return localVarFp.getUserCount(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreUser(userId: string, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.restoreUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProfileImage operation in UserApi.
 * @export
 * @interface UserApiCreateProfileImageRequest
 */
export interface UserApiCreateProfileImageRequest {
    /**
     * 
     * @type {File}
     * @memberof UserApiCreateProfileImage
     */
    readonly file: File
}

/**
 * Request parameters for createUser operation in UserApi.
 * @export
 * @interface UserApiCreateUserRequest
 */
export interface UserApiCreateUserRequest {
    /**
     * 
     * @type {CreateUserDto}
     * @memberof UserApiCreateUser
     */
    readonly createUserDto: CreateUserDto
}

/**
 * Request parameters for deleteUser operation in UserApi.
 * @export
 * @interface UserApiDeleteUserRequest
 */
export interface UserApiDeleteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiDeleteUser
     */
    readonly userId: string
}

/**
 * Request parameters for getAllUsers operation in UserApi.
 * @export
 * @interface UserApiGetAllUsersRequest
 */
export interface UserApiGetAllUsersRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UserApiGetAllUsers
     */
    readonly isAll: boolean
}

/**
 * Request parameters for getProfileImage operation in UserApi.
 * @export
 * @interface UserApiGetProfileImageRequest
 */
export interface UserApiGetProfileImageRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetProfileImage
     */
    readonly userId: string
}

/**
 * Request parameters for getUserById operation in UserApi.
 * @export
 * @interface UserApiGetUserByIdRequest
 */
export interface UserApiGetUserByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserById
     */
    readonly userId: string
}

/**
 * Request parameters for getUserCount operation in UserApi.
 * @export
 * @interface UserApiGetUserCountRequest
 */
export interface UserApiGetUserCountRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UserApiGetUserCount
     */
    readonly admin?: boolean
}

/**
 * Request parameters for restoreUser operation in UserApi.
 * @export
 * @interface UserApiRestoreUserRequest
 */
export interface UserApiRestoreUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiRestoreUser
     */
    readonly userId: string
}

/**
 * Request parameters for updateUser operation in UserApi.
 * @export
 * @interface UserApiUpdateUserRequest
 */
export interface UserApiUpdateUserRequest {
    /**
     * 
     * @type {UpdateUserDto}
     * @memberof UserApiUpdateUser
     */
    readonly updateUserDto: UpdateUserDto
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserApiCreateProfileImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createProfileImage(requestParameters: UserApiCreateProfileImageRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createProfileImage(requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(requestParameters: UserApiCreateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(requestParameters.createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(requestParameters: UserApiDeleteUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetAllUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAllUsers(requestParameters: UserApiGetAllUsersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getAllUsers(requestParameters.isAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMyUserInfo(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMyUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetProfileImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProfileImage(requestParameters: UserApiGetProfileImageRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getProfileImage(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(requestParameters: UserApiGetUserByIdRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserById(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserCount(requestParameters: UserApiGetUserCountRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserCount(requestParameters.admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiRestoreUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public restoreUser(requestParameters: UserApiRestoreUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).restoreUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(requestParameters: UserApiUpdateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(requestParameters.updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


