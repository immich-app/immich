<script lang="ts">
  import Combobox from '$lib/components/shared-components/combobox.svelte';
  import DateInput from '$lib/elements/DateInput.svelte';
  import DurationInput from '$lib/elements/DurationInput.svelte';
  import type { TimelineAsset } from '$lib/managers/timeline-manager/types';
  import {
    calcNewDate,
    getPreferredTimeZone,
    getTimezones,
    toIsoDate,
    type ZoneOption,
  } from '$lib/modals/timezone-utils';
  import { user } from '$lib/stores/user.store';
  import { getSelectedAssets } from '$lib/utils/asset-utils';
  import { handleError } from '$lib/utils/handle-error';
  import { updateAssets } from '@immich/sdk';
  import { Button, Field, HStack, Modal, ModalBody, ModalFooter, Switch, VStack } from '@immich/ui';
  import { mdiCalendarEdit } from '@mdi/js';
  import { DateTime } from 'luxon';
  import { t } from 'svelte-i18n';
  interface Props {
    initialDate?: DateTime;
    initialTimeZone?: string;
    currentInterval?: { start: DateTime; end: DateTime };
    assets: TimelineAsset[];
    clearSelect: () => void;
    onClose: (success: boolean) => void;
  }

  let {
    initialDate = DateTime.now(),
    initialTimeZone,
    currentInterval,
    assets,
    clearSelect,
    onClose,
  }: Props = $props();

  let showRelative = $state(false);
  let selectedDuration = $state(0);
  let selectedDate = $state(initialDate.toFormat("yyyy-MM-dd'T'HH:mm:ss.SSS"));
  const timezones = $derived(getTimezones(selectedDate));
  // svelte-ignore state_referenced_locally
  let lastSelectedTimezone = $state(getPreferredTimeZone(initialDate, initialTimeZone, timezones));
  // the offsets (and validity) for time zones may change if the date is changed, which is why we recompute the list
  let selectedOption = $derived(getPreferredTimeZone(initialDate, initialTimeZone, timezones, lastSelectedTimezone));

  const handleConfirm = async () => {
    const ids = getSelectedAssets(assets, $user);
    try {
      if (showRelative && (selectedDuration || selectedOption)) {
        await updateAssets({
          assetBulkUpdateDto: {
            ids,
            dateTimeRelative: selectedDuration,
            timeZone: selectedOption?.value,
          },
        });
        clearSelect();
        return;
      }
      const isoDate = toIsoDate(selectedDate, selectedOption);
      await updateAssets({ assetBulkUpdateDto: { ids, dateTimeOriginal: isoDate } });
      clearSelect();
    } catch (error) {
      handleError(error, $t('errors.unable_to_change_date'));
    }
  };

  let intervalFrom = $derived(
    currentInterval ? calcNewDate(currentInterval.start, selectedDuration, selectedOption?.value) : undefined,
  );
  let intervalTo = $derived(
    currentInterval ? calcNewDate(currentInterval.end, selectedDuration, selectedOption?.value) : undefined,
  );

  // when changing the time zone, assume the configured date/time is meant for that time zone (instead of updating it)
  const date = $derived(DateTime.fromISO(selectedDate, { zone: selectedOption?.value, setZone: true }));
</script>

<Modal title={$t('edit_date_and_time')} icon={mdiCalendarEdit} onClose={() => onClose(false)} size="large">
  <ModalBody>
    <VStack fullWidth>
      <HStack fullWidth>
        <Field color="muted" label={$t('edit_date_and_time_by_offset')}>
          <Switch data-testid="edit-by-offset-switch" bind:checked={showRelative} />
        </Field>
      </HStack>
      {#if showRelative}
        <HStack fullWidth>
          <label class="immich-form-label" for="relativedatetime">{$t('offset')}</label>
        </HStack>
        <HStack fullWidth>
          <DurationInput class="immich-form-input  text-gray-700" id="relativedatetime" bind:value={selectedDuration} />
        </HStack>
      {:else}
        <HStack fullWidth>
          <label class="immich-form-label" for="datetime">{$t('date_and_time')}</label>
        </HStack>
        <HStack fullWidth>
          <DateInput class="immich-form-input" id="datetime" type="datetime-local" bind:value={selectedDate} />
        </HStack>
      {/if}
      <div class="w-full">
        <Combobox
          bind:selectedOption
          label={$t('timezone')}
          options={timezones}
          placeholder={$t('search_timezone')}
          onSelect={(option) => (lastSelectedTimezone = option as ZoneOption)}
        ></Combobox>
      </div>
      <VStack fullWidth class={!showRelative || !currentInterval ? 'invisible' : ''}>
        <HStack fullWidth>
          <div class="immich-form-label" data-testid="interval-preview">{$t('new_date_range')}</div>
        </HStack>
        <HStack fullWidth>
          <label class="immich-form-label" for="from">From</label>
          <DateInput class="immich-form-input" id="from" type="datetime-local" bind:value={intervalFrom} />
          <label class="immich-form-label" for="from">To</label>
          <DateInput class="immich-form-input" id="to" type="datetime-local" bind:value={intervalTo} />
        </HStack>
      </VStack>
    </VStack>
  </ModalBody>
  <ModalFooter>
    <HStack fullWidth>
      <Button shape="round" color="secondary" fullWidth onclick={() => onClose(false)}>
        {$t('cancel')}
      </Button>
      <Button shape="round" color="primary" fullWidth onclick={handleConfirm} disabled={!date.isValid}>
        {$t('confirm')}
      </Button>
    </HStack>
  </ModalFooter>
</Modal>
